export const metaii_inputs = [
    {
        "filename": "i01a__demo__AEXP2_backup_value_assignments.txt",
        "contents": "fern:=5+6;\r\nace:=fern*5;\r\nwaldo:=fern+alpha/-beta^gamma;\r\nfern:=5<=6;\r\nace:=fern*5>=bob;\r\nwaldo:=fern<-alpha<=beta->gamma;\r\n"
    },
    {
        "filename": "i01__demo__AEXP_example_assignments.txt",
        "contents": "fern:=5+6;\r\nace:=fern*5;\r\nwaldo:=fern+alpha/-beta^gamma;\r\n"
    },
    {
        "filename": "i02a__demo__AEXP_example_assignment_compiler.txt",
        "contents": ".SYNTAX AEXP\r\n\r\nAEXP = AS $AS ;\r\nAS = ID .OUT(.TB 'address ' * .NL) ':=' RX1 .OUT(.TB 'store' .NL) ';' ;\r\nRX1 = RX2 ('='  RX2 .OUT(.TB 'eq' .NL) /\r\n           '<'  RX2 .OUT(.TB 'lt' .NL) /\r\n           '>'  RX2 .OUT(.TB 'gt' .NL) /\r\n           '<=' RX2 .OUT(.TB 'le' .NL) /\r\n           '>=' RX2 .OUT(.TB 'ge' .NL) /\r\n           .EMPTY) ;\r\nRX2 = '~' EX0 .OUT(.TB 'not' .NL) / EX0 ;\r\nEX0 = EX1 ('<-' EX1 .OUT(.TB 'shl' .NL) /\r\n           '->' EX2 .OUT(.TB 'shr' .NL) /\r\n           .EMPTY) ;\r\nEX1 = EX2 $('+' EX2 .OUT(.TB 'add' .NL) /\r\n            '-' EX2 .OUT(.TB 'sub' .NL) ) ;\r\nEX2 = EX3 $('*' EX3 .OUT(.TB 'mpy' .NL) /\r\n            '/' EX3 .OUT(.TB 'div' .NL) ) ;\r\nEX3 = EX4 $('^' EX3 .OUT(.TB 'exp' .NL)) ;\r\nEX4 = '+' EX5 / '-' EX5 .OUT(.TB 'minus' .NL) / EX5 ;\r\nEX5 = ID  .OUT(.TB 'load ' * .NL) /\r\n      NUMBER .OUT(.TB 'literal ' * .NL) /\r\n      '(' EX1 ')' ;\r\n\r\n.TOKENS\r\n\r\nPREFIX : $.ANY(32!9!13!10) ;\r\nID     : PREFIX .TOKEN .ANY('A:'Z!'a:'z) $(.ANY('A:'Z!'a:'z) / .ANY('0:'9)) .DELTOK ;\r\nNUMBER : PREFIX .TOKEN .ANY('0:'9) $.ANY('0:'9) .DELTOK ;\r\n\r\n.END\r\n"
    },
    {
        "filename": "i02b__demo__AEXP2_backup_assignment_compiler.txt",
        "contents": ".SYNTAX AEXP2\r\n\r\nAEXP2 = AS $AS ;\r\nAS = ID .OUT(.TB 'address ' * .NL) ':=' RX1 .OUT(.TB 'store' .NL) ';' ;\r\nRX1 = RX2 ['='  RX2 .OUT(.TB 'eq' .NL) |\r\n           '<'  RX2 .OUT(.TB 'lt' .NL) |\r\n           '>'  RX2 .OUT(.TB 'gt' .NL) |\r\n           '<=' RX2 .OUT(.TB 'le' .NL) |\r\n           '>=' RX2 .OUT(.TB 'ge' .NL) |\r\n           .EMPTY] ;\r\nRX2 = '~' EX0 .OUT(.TB 'not' .NL) / EX0 ;\r\nEX0 = EX1 ('<-' EX1 .OUT(.TB 'shl' .NL) /\r\n           '->' EX2 .OUT(.TB 'shr' .NL) /\r\n           .EMPTY) ;\r\nEX1 = EX2 $['+' EX2 .OUT(.TB 'add' .NL) |\r\n            '-' EX2 .OUT(.TB 'sub' .NL) ] ;\r\nEX2 = EX3 $('*' EX3 .OUT(.TB 'mpy' .NL) /\r\n            '/' EX3 .OUT(.TB 'div' .NL) ) ;\r\nEX3 = EX4 $('^' EX3 .OUT(.TB 'exp' .NL)) ;\r\nEX4 = '+' EX5 / '-' EX5 .OUT(.TB 'minus' .NL) / EX5 ;\r\nEX5 = ID  .OUT(.TB 'load ' * .NL) /\r\n      NUMBER .OUT(.TB 'literal ' * .NL) /\r\n      '(' EX0 ')' ;\r\n\r\n.TOKENS\r\n\r\nPREFIX : $.ANY(32!9!13!10) ;\r\nID     : PREFIX .TOKEN .ANY('A:'Z!'a:'z) $(.ANY('A:'Z!'a:'z) / .ANY('0:'9)) .DELTOK ;\r\nNUMBER : PREFIX .TOKEN .ANY('0:'9) $.ANY('0:'9) .DELTOK ;\r\n\r\n.END\r\n"
    },
    {
        "filename": "i02__demo__AEXP_example_assignment_compiler.txt",
        "contents": ".SYNTAX AEXP\r\n\r\nAEXP = AS $AS .,\r\nAS = .ID .OUT('address ' *) ':=' EX1 .OUT('store') ';' .,\r\nEX1 = EX2 $('+' EX2 .OUT('add') /\r\n            '-' EX2 .OUT('sub') ) .,\r\nEX2 = EX3 $('*' EX3 .OUT('mpy') /\r\n            '/' EX3 .OUT('div') ) .,\r\nEX3 = EX4 $('^' EX3 .OUT('exp')) .,\r\nEX4 = '+' EX5 / '-' EX5 .OUT('minus') / EX5 .,\r\nEX5 = .ID  .OUT('load ' *) /\r\n      .NUMBER .OUT('literal ' *) /\r\n      '(' EX1 ')' .,\r\n\r\n.END\r\n"
    },
    {
        "filename": "i03__Meta_II_syntax_(paper_fig__5).txt",
        "contents": ".SYNTAX PROGRAM\r\n\r\nOUT1 = '*1' .OUT('GN1') / '*2' .OUT('GN2') /\r\n'*' .OUT('CI') / .STRING .OUT('CL '*).,\r\n\r\nOUTPUT = ('.OUT' '('\r\n$OUT1 ')' / '.LABEL' .OUT('LB') OUT1) .OUT('OUT') .,\r\n\r\nEX3 = .ID .OUT('CLL '*) / .STRING\r\n.OUT('TST '*) / '.ID' .OUT('ID') /\r\n'.NUMBER' .OUT('NUM') /\r\n'.STRING' .OUT('SR') / '(' EX1 ')' /\r\n'.EMPTY' .OUT('SET') /\r\n'$' .LABEL *1 EX3\r\n.OUT('BT ' *1) .OUT('SET').,\r\n\r\nEX2 = (EX3 .OUT('BF ' *1) / OUTPUT)\r\n$(EX3 .OUT('BE') / OUTPUT)\r\n.LABEL *1 .,\r\n\r\nEX1 = EX2 $('/' .OUT('BT ' *1) EX2 )\r\n.LABEL *1 .,\r\n\r\nST = .ID .LABEL * '=' EX1\r\n'.,' .OUT('R').,\r\n\r\nPROGRAM = '.SYNTAX' .ID .OUT('ADR ' *)\r\n$ ST '.END' .OUT('END').,\r\n\r\n.END\r\n"
    },
    {
        "filename": "i04a__Meta_II_syntax_(i03_reordered_and_tokens).txt",
        "contents": ".SYNTAX PROGRAM\r\n\r\nPROGRAM = '.SYNTAX' ID .OUT(.LB .TB 'ADR ' * .NL)\r\n          $ ST\r\n          '.END' .OUT(.TB 'END' .NL) ;\r\n\r\nST = ID .OUT(.LB * .NL) '=' EX1 '.,' .OUT(.TB 'R' .NL) ;\r\n\r\nEX1 = EX2 $('/' .OUT(.TB 'BT L' # .NL) EX2 )\r\n      .OUT(.LB 'L'# .NL) ;\r\n\r\nEX2 = (EX3 .OUT(.TB 'BF L' # .NL) / OUTPUT)\r\n      $(EX3 .OUT(.TB 'BE' .NL) / OUTPUT)\r\n      .OUT(.LB 'L'# .NL) ;\r\n\r\nEX3 = ID        .OUT(.TB 'CLL '* .NL) /\r\n      STRING    .OUT(.TB 'TST '* .NL) /\r\n      '.ID'     .OUT(.TB 'ID' .NL)    /\r\n      '.NUMBER' .OUT(.TB 'NUM' .NL)   /\r\n      '.STRING' .OUT(.TB 'SR' .NL)    /\r\n      '(' EX1 ')'             /\r\n      '.EMPTY'  .OUT(.TB 'SET' .NL)   /\r\n      '$' .OUT(.LB 'L'# .NL) EX3 .OUT(.TB 'BT L' # .NL) .OUT(.TB 'SET' .NL) ;\r\n\r\nOUTPUT = ('.OUT' '('$OUT1 ')' /\r\n          '.LABEL' .OUT(.TB 'LB' .NL) OUT1)\r\n         .OUT(.TB 'OUT' .NL) ;\r\n\r\nOUT1 = '*1'    .OUT(.TB 'GN1' .NL)  /\r\n       '*2'    .OUT(.TB 'GN2' .NL)  /\r\n       '*'     .OUT(.TB 'CI' .NL)   /\r\n       STRING  .OUT(.TB 'CL '* .NL) ;\r\n\r\n.TOKENS\r\n\r\nPREFIX : $.ANY(32!9!13!10) ;\r\nID     : PREFIX .TOKEN ALPHA $(ALPHA/DIGIT) .DELTOK ;\r\nNUMBER : PREFIX .TOKEN DIGIT $DIGIT .DELTOK ;\r\nSTRING : PREFIX .TOKEN .ANY(39) $.ANYBUT(13!10!39) .ANY(39) .DELTOK ;\r\nALPHA  : .ANY('A:'Z!'a:'z) ;\r\nDIGIT  : .ANY('0:'9) ;\r\n\r\n.END\r\n"
    },
    {
        "filename": "i04__Meta_II_syntax_(i03_reordered).txt",
        "contents": ".SYNTAX PROGRAM\r\n\r\nPROGRAM = '.SYNTAX' .ID .OUT('ADR ' *)\r\n          $ ST\r\n          '.END' .OUT('END') .,\r\n\r\nST = .ID .LABEL * '=' EX1 '.,' .OUT('R') .,\r\n\r\nEX1 = EX2 $('/' .OUT('BT ' *1) EX2 )\r\n      .LABEL *1 .,\r\n\r\nEX2 = (EX3 .OUT('BF ' *1) / OUTPUT)\r\n      $(EX3 .OUT('BE') / OUTPUT)\r\n      .LABEL *1 .,\r\n\r\nEX3 = .ID       .OUT('CLL '*) /\r\n      .STRING   .OUT('TST '*) /\r\n      '.ID'     .OUT('ID')    /\r\n      '.NUMBER' .OUT('NUM')   /\r\n      '.STRING' .OUT('SR')    /\r\n      '(' EX1 ')'             /\r\n      '.EMPTY'  .OUT('SET')   /\r\n      '$' .LABEL *1 EX3 .OUT('BT ' *1) .OUT('SET') .,\r\n\r\nOUTPUT = ('.OUT' '('$OUT1 ')' /\r\n          '.LABEL' .OUT('LB') OUT1)\r\n         .OUT('OUT') .,\r\n\r\nOUT1 = '*1'    .OUT('GN1')  /\r\n       '*2'    .OUT('GN2')  /\r\n       '*'     .OUT('CI')   /\r\n       .STRING .OUT('CL '*) .,\r\n\r\n.END\r\n"
    },
    {
        "filename": "i05__add_semicolon_line_end.txt",
        "contents": ".SYNTAX PROGRAM\r\n\r\nPROGRAM = '.SYNTAX' .ID .OUT('ADR ' *)\r\n          $ ST\r\n          '.END' .OUT('END') .,\r\n\r\nST = .ID .LABEL * '=' EX1 ';' .OUT('R') .,\r\n\r\nEX1 = EX2 $('/' .OUT('BT ' *1) EX2 )\r\n      .LABEL *1 .,\r\n\r\nEX2 = (EX3 .OUT('BF ' *1) / OUTPUT)\r\n      $(EX3 .OUT('BE') / OUTPUT)\r\n      .LABEL *1 .,\r\n\r\nEX3 = .ID       .OUT('CLL '*) /\r\n      .STRING   .OUT('TST '*) /\r\n      '.ID'     .OUT('ID')    /\r\n      '.NUMBER' .OUT('NUM')   /\r\n      '.STRING' .OUT('SR')    /\r\n      '(' EX1 ')'             /\r\n      '.EMPTY'  .OUT('SET')   /\r\n      '$' .LABEL *1 EX3 .OUT('BT ' *1) .OUT('SET') .,\r\n\r\nOUTPUT = ('.OUT' '('$OUT1 ')' /\r\n          '.LABEL' .OUT('LB') OUT1)\r\n         .OUT('OUT') .,\r\n\r\nOUT1 = '*1'    .OUT('GN1')  /\r\n       '*2'    .OUT('GN2')  /\r\n       '*'     .OUT('CI')   /\r\n       .STRING .OUT('CL '*) .,\r\n\r\n.END\r\n"
    },
    {
        "filename": "i06__use_semicolon_line_end.txt",
        "contents": ".SYNTAX PROGRAM\r\n\r\nPROGRAM = '.SYNTAX' .ID .OUT('ADR ' *)\r\n          $ ST\r\n          '.END' .OUT('END') ;\r\n\r\nST = .ID .LABEL * '=' EX1 ';' .OUT('R') ;\r\n\r\nEX1 = EX2 $('/' .OUT('BT ' *1) EX2 )\r\n      .LABEL *1 ;\r\n\r\nEX2 = (EX3 .OUT('BF ' *1) / OUTPUT)\r\n      $(EX3 .OUT('BE') / OUTPUT)\r\n      .LABEL *1 ;\r\n\r\nEX3 = .ID       .OUT('CLL '*) /\r\n      .STRING   .OUT('TST '*) /\r\n      '.ID'     .OUT('ID')    /\r\n      '.NUMBER' .OUT('NUM')   /\r\n      '.STRING' .OUT('SR')    /\r\n      '(' EX1 ')'             /\r\n      '.EMPTY'  .OUT('SET')   /\r\n      '$' .LABEL *1 EX3 .OUT('BT ' *1) .OUT('SET') ;\r\n\r\nOUTPUT = ('.OUT' '('$OUT1 ')' /\r\n          '.LABEL' .OUT('LB') OUT1)\r\n         .OUT('OUT') ;\r\n\r\nOUT1 = '*1'    .OUT('GN1')  /\r\n       '*2'    .OUT('GN2')  /\r\n       '*'     .OUT('CI')   /\r\n       .STRING .OUT('CL '*) ;\r\n\r\n.END\r\n"
    },
    {
        "filename": "i07__add_new_output_control.txt",
        "contents": ".SYNTAX PROGRAM\r\n\r\nPROGRAM = '.SYNTAX' .ID .OUT('ADR ' *)\r\n          $ ST\r\n          '.END' .OUT('END') ;\r\n\r\nST = .ID .LABEL * '=' EX1 ';' .OUT('R') ;\r\n\r\nEX1 = EX2 $('/' .OUT('BT ' *1) EX2 )\r\n      .LABEL *1 ;\r\n\r\nEX2 = (EX3 .OUT('BF ' *1) / OUTPUT)\r\n      $(EX3 .OUT('BE') / OUTPUT)\r\n      .LABEL *1 ;\r\n\r\nEX3 = .ID       .OUT('CLL '*) /\r\n      .STRING   .OUT('TST '*) /\r\n      '.ID'     .OUT('ID')    /\r\n      '.NUMBER' .OUT('NUM')   /\r\n      '.STRING' .OUT('SR')    /\r\n      '(' EX1 ')'             /\r\n      '.EMPTY'  .OUT('SET')   /\r\n      '$' .LABEL *1 EX3 .OUT('BT ' *1) .OUT('SET') ;\r\n \r\nOUTPUT = ('.OUT' '('$OUT1 ')' / \r\n          '.LABEL' .OUT('LB') OUT1) \r\n         .OUT('OUT') ;\r\n\r\nOUT1 = '*1'    .OUT('GN1')  /\r\n       '*2'    .OUT('GN2')  /\r\n       '*'     .OUT('CI')   /\r\n       .STRING .OUT('CL '*) /\r\n       '#'     .OUT('GN')   /\r\n       '.NL'   .OUT('NL')   /\r\n       '.LB'   .OUT('LB')   /\r\n       '.TB'   .OUT('TB')   /\r\n       '.LM+'  .OUT('LMI')  /\r\n       '.LM-'  .OUT('LMD')  ;\r\n\r\n.END\r\n"
    },
    {
        "filename": "i08__delete_old_output_control.txt",
        "contents": ".SYNTAX PROGRAM\r\n\r\nPROGRAM = '.SYNTAX' .ID .OUT('ADR ' *)\r\n          $ ST \r\n          '.END' .OUT('END') ;\r\n\r\nST = .ID .LABEL * '=' EX1 ';' .OUT('R') ;\r\n\r\nEX1 = EX2 $('/' .OUT('BT ' *1) EX2 )\r\n      .LABEL *1 ;\r\n\r\nEX2 = (EX3 .OUT('BF ' *1) / OUTPUT)\r\n      $(EX3 .OUT('BE') / OUTPUT)\r\n      .LABEL *1 ;\r\n\r\nEX3 = .ID       .OUT('CLL '*) /\r\n      .STRING   .OUT('TST '*) /\r\n      '.ID'     .OUT('ID')    /\r\n      '.NUMBER' .OUT('NUM')   /\r\n      '.STRING' .OUT('SR')    /\r\n      '(' EX1 ')'             /\r\n      '.EMPTY'  .OUT('SET')   /\r\n      '$' .LABEL *1 EX3 .OUT('BT ' *1) .OUT('SET') ;\r\n\r\nOUTPUT = '.OUT' '('$OUT1 ')' ;\r\n\r\nOUT1 = '*'     .OUT('CI')   / \r\n       .STRING .OUT('CL '*) /\r\n       '#'     .OUT('GN')   /\r\n       '.NL'   .OUT('NL')   /\r\n       '.LB'   .OUT('LB')   /\r\n       '.TB'   .OUT('TB')   /\r\n       '.LM+'  .OUT('LMI')  /\r\n       '.LM-'  .OUT('LMD')  ;\r\n\r\n.END\r\n"
    },
    {
        "filename": "i09__use_new_output_control.txt",
        "contents": ".SYNTAX PROGRAM\r\n\r\nPROGRAM = '.SYNTAX' .ID .OUT(.LB .TB 'ADR ' * .NL)\r\n          $ ST\r\n          '.END' .OUT(.TB 'END' .NL) ;\r\n\r\nST = .ID .OUT(.LB * .NL) '=' EX1 ';' .OUT(.TB 'R' .NL) ;\r\n\r\nEX1 = EX2 $('/' .OUT(.TB 'BT L'# .NL) EX2 )\r\n      .OUT(.LB 'L'# .NL) ;\r\n\r\nEX2 = (EX3 .OUT(.TB 'BF L'# .NL) / OUTPUT)\r\n      $(EX3 .OUT(.TB 'BE' .NL) / OUTPUT)\r\n      .OUT(.LB 'L'# .NL) ;\r\n\r\nEX3 = .ID       .OUT(.TB 'CLL '* .NL) /\r\n      .STRING   .OUT(.TB 'TST '* .NL) /\r\n      '.ID'     .OUT(.TB 'ID' .NL)    /\r\n      '.NUMBER' .OUT(.TB 'NUM' .NL)   /\r\n      '.STRING' .OUT(.TB 'SR' .NL)    /\r\n      '(' EX1 ')'                     /\r\n      '.EMPTY'  .OUT(.TB 'SET' .NL)   /\r\n      '$' .OUT(.LB 'L'# .NL) EX3 .OUT(.TB 'BT L'# .NL) .OUT(.TB 'SET' .NL) ;\r\n\r\nOUTPUT = '.OUT' '('$OUT1 ')' ;\r\n\r\nOUT1 = '*'     .OUT(.TB 'CI' .NL)   /\r\n       .STRING .OUT(.TB 'CL '* .NL) /\r\n       '#'     .OUT(.TB 'GN' .NL)   /\r\n       '.NL'   .OUT(.TB 'NL' .NL)   /\r\n       '.LB'   .OUT(.TB 'LB' .NL)   /\r\n       '.TB'   .OUT(.TB 'TB' .NL)   /\r\n       '.LM+'  .OUT(.TB 'LMI' .NL)  /\r\n       '.LM-'  .OUT(.TB 'LMD' .NL)  ;\r\n\r\n.END\r\n"
    },
    {
        "filename": "i10__convert_i09_to_js_functions.txt",
        "contents": ".SYNTAX PROGRAM\r\n\r\nPROGRAM = '.SYNTAX' .ID\r\n            .OUT(.LB '// '*' compiler' .NL)\r\n            .OUT('function compiler (input) {' .LM+ .NL)\r\n            .OUT('inbuf = input ;' .NL)\r\n            .OUT('inp = 0 ;' .NL)\r\n            .OUT('outbuf = \"\" ;' .NL)\r\n            .OUT('margin = 0 ;' .NL)\r\n            .OUT('gnlabel = 1 ;' .NL)\r\n            .OUT('rule'*'() ;' .NL)\r\n            .OUT('return outbuf ;' .NL)\r\n            .OUT(.LM- '} ;' .NL .NL)\r\n          $ ST\r\n          '.END' ;\r\n\r\nST = .ID .OUT(.LB 'function rule'*' () {' .LM+ .NL)\r\n     .OUT('var rname = \"'*'\" ;' .NL)\r\n     .OUT('var rlabel = 0 ;' .NL)\r\n     '=' EX1 ';'\r\n     .OUT(.LM- '} ;' .NL .NL) ;\r\n\r\nEX1 = EX2 $('/' .OUT('if (!flag) {' .LM+ .NL) EX2 .OUT(.LM- '} ;' .NL) ) ;\r\n\r\nEX2 = (EX3 .OUT('if (flag) {' .LM+ .NL) / OUTPUT .OUT('if (true) {' .LM+ .NL) )\r\n      $(EX3 .OUT('if (!flag) runBEjsfn(rname);' .NL) / OUTPUT)\r\n      .OUT(.LM- '} ;' .NL) ;\r\n\r\nEX3 = .ID       .OUT('rule'*'();' .NL) /\r\n      .STRING   .OUT('runTST('*');' .NL) /\r\n      '.ID'     .OUT('runID();' .NL)     /\r\n      '.NUMBER' .OUT('runNUM();' .NL)    /\r\n      '.STRING' .OUT('runSR();' .NL)     /\r\n      '(' EX1 ')'                        /\r\n      '.EMPTY'  .OUT('runSET();' .NL)    /\r\n      '$' .OUT('runSET();' .NL)\r\n          .OUT('while (flag) {' .LM+ .NL)\r\n           EX3 \r\n          .OUT('};' .LM- .NL) \r\n          .OUT('runSET();' .NL) ;\r\n\r\nOUTPUT = '.OUT' '('$OUT1 ')' ;\r\n\r\nOUT1 = '*'     .OUT('runCI();' .NL)    /\r\n       .STRING .OUT('runCL('*');' .NL) /\r\n       '#'     .OUT('if (rlabel == 0) { rlabel = gnlabel; gnlabel++ ; } ;' .NL)\r\n               .OUT('runCL(rlabel.toString());' .NL) /\r\n       '.NL'   .OUT('runextNL();' .NL)    /\r\n       '.LB'   .OUT('runLB();' .NL)    /\r\n       '.TB'   .OUT('runextTB();' .NL)    /\r\n       '.LM+'  .OUT('runextLMI();' .NL)   /\r\n       '.LM-'  .OUT('runextLMD();' .NL)   ;\r\n\r\n.END\r\n"
    },
    {
        "filename": "i11jf__add_token_rules_to_i10.txt",
        "contents": ".SYNTAX PROGRAM\r\n\r\nPROGRAM = '.SYNTAX' .ID\r\n            .OUT(.LB '// '*' compiler' .NL)\r\n            .OUT('function compiler (input) {' .LM+ .NL)\r\n            .OUT('inbuf = input ;' .NL)\r\n            .OUT('inp = 0 ;' .NL)\r\n            .OUT('outbuf = \"\" ;' .NL)\r\n            .OUT('margin = 0 ;' .NL)\r\n            .OUT('gnlabel = 1 ;' .NL)\r\n            .OUT('runextTFF();' .NL)\r\n            .OUT('rule'*'() ;' .NL)\r\n            .OUT('return outbuf ;' .NL)\r\n            .OUT(.LM- '} ;' .NL .NL)\r\n          $ PR\r\n          '.TOKENS'\r\n          $ TR\r\n          '.END' ;\r\n\r\nPR = .ID .OUT(.LB 'function rule'*' () {' .LM+ .NL)\r\n     .OUT('var rname = \"'*'\" ;' .NL)\r\n     .OUT('var rlabel = 0 ;' .NL)\r\n     '=' EX1 ';'\r\n     .OUT(.LM- '} ;' .NL .NL) ;\r\n\r\nTR = .ID .OUT(.LB 'function rule'*' () {' .LM+ .NL)\r\n     .OUT('var rname = \"'*'\" ;' .NL)\r\n     .OUT('var rlabel = 0 ;' .NL)\r\n     ':' TX1 ';'\r\n     .OUT(.LM- '} ;' .NL .NL) ;\r\n\r\nEX1 = EX2 $('/' .OUT('if (!flag) {' .LM+ .NL) EX2 .OUT(.LM- '} ;' .NL) ) ;\r\n\r\nEX2 = (EX3 .OUT('if (flag) {' .LM+ .NL) / OUTPUT .OUT('if (true) {' .LM+ .NL) )\r\n      $(EX3 .OUT('if (!flag) runBEjsfn(rname);' .NL) / OUTPUT)\r\n      .OUT(.LM- '} ;' .NL) ;\r\n\r\nEX3 = .ID       .OUT('rule'*'();' .NL) /\r\n      .STRING   .OUT('runTST('*');' .NL) /\r\n      '.ID'     .OUT('runID();' .NL)     /\r\n      '.NUMBER' .OUT('runNUM();' .NL)    /\r\n      '.STRING' .OUT('runSR();' .NL)     /\r\n      '(' EX1 ')'                        /\r\n      '.EMPTY'  .OUT('runSET();' .NL)    /\r\n      '$' .OUT('runSET();' .NL)\r\n          .OUT('while (flag) {' .LM+ .NL)\r\n           EX3 \r\n          .OUT('};' .LM- .NL) \r\n          .OUT('runSET();' .NL) ;\r\n\r\nOUTPUT = '.OUT' '('$OUT1 ')' ;\r\n\r\nOUT1 = '*'     .OUT('runCI();' .NL)    /\r\n       .STRING .OUT('runCL('*');' .NL) /\r\n       .NUMBER .OUT('runextCC('*');' .NL) /\r\n       '#'     .OUT('if (rlabel == 0) { rlabel = gnlabel; gnlabel++ ; } ;' .NL)\r\n               .OUT('runCL(rlabel.toString());' .NL) /\r\n       '.NL'   .OUT('runextNL();' .NL)    /\r\n       '.LB'   .OUT('runLB();' .NL)    /\r\n       '.TB'   .OUT('runextTB();' .NL)    /\r\n       '.LM+'  .OUT('runextLMI();' .NL)   /\r\n       '.LM-'  .OUT('runextLMD();' .NL)   ;\r\n\r\nTX1 = TX2 $('/' .OUT('if (!flag) {' .LM+ .NL) TX2 .OUT(.LM- '} ;' .NL) ) ;\r\n\r\nTX2 = TX3 .OUT('if (flag) {' .LM+ .NL) \r\n      $(TX3 .OUT('if (!flag) return;' .NL) ) \r\n      .OUT(.LM- '} ;' .NL) ;\r\n\r\nTX3 = ( '.TOKEN'         .OUT('runextTFT();' .NL) /\r\n        '.DELTOK'        .OUT('runextTFF();' .NL) /\r\n        '$' .OUT('runSET();' .NL)\r\n            .OUT('while (flag) {' .LM+ .NL)\r\n             TX3 \r\n            .OUT('};' .LM- .NL)                   )\r\n        .OUT('runSET();' .NL)                       /\r\n      '.ANYBUT(' CX1 ')' .OUT('runextNOT();' .NL)\r\n                         .OUT('runextSCN();' .NL)   /\r\n      '.ANY(' CX1 ')'    .OUT('runextSCN();' .NL)   /\r\n      .ID                .OUT('rule'*'();' .NL)     /\r\n      '(' TX1 ')'                                   ;\r\n            \r\nCX1 = CX2 $('!' .OUT('if (!flag) {' .LM+ .NL) CX2 .OUT(.LM- '} ;' .NL) ) ;\r\nCX2 = CX3 (':' .OUT('runextCGE('*');' .NL) .OUT('if (flag) {' .LM+ .NL) \r\n               CX3\r\n               .OUT('runextCLE('*');' .NL) .OUT(.LM- '} ;' .NL) /\r\n           .EMPTY .OUT('runextCE('*');' .NL)                    ) ;\r\nCX3 = .NUMBER ;\r\n\r\n.END\r\n"
    },
    {
        "filename": "i11__add_token_rules_to_i09.txt",
        "contents": ".SYNTAX PROGRAM\r\n\r\nPROGRAM = '.SYNTAX' .ID .OUT(.LB .TB 'ADR ' * .NL)\r\n          $ PR  \r\n          '.TOKENS'\r\n          $ TR\r\n          '.END' .OUT(.TB 'END' .NL) ;\r\n\r\nPR = .ID .OUT(.LB * .NL) '=' EX1 ';' .OUT(.TB 'R' .NL) ; \r\n\r\nTR = .ID .OUT(.LB * .NL) ':' TX1 ';' .OUT(.TB 'R' .NL) ;\r\n\r\nEX1 = EX2 $('/' .OUT(.TB 'BT L'# .NL) EX2 )\r\n      .OUT(.LB 'L'# .NL) ;\r\n\r\nEX2 = (EX3 .OUT(.TB 'BF L'# .NL) / OUTPUT)\r\n      $(EX3 .OUT(.TB 'BE' .NL) / OUTPUT)\r\n      .OUT(.LB 'L'# .NL) ;\r\n\r\nEX3 = .ID       .OUT(.TB 'CLL '* .NL) /\r\n      .STRING   .OUT(.TB 'TST '* .NL) /\r\n      '.ID'     .OUT(.TB 'ID' .NL)    /\r\n      '.NUMBER' .OUT(.TB 'NUM' .NL)   /\r\n      '.STRING' .OUT(.TB 'SR' .NL)    /\r\n      '(' EX1 ')'                     /\r\n      '.EMPTY'  .OUT(.TB 'SET' .NL)   /\r\n      '$' .OUT(.LB 'L'# .NL) EX3 .OUT(.TB 'BT L'# .NL) .OUT(.TB 'SET' .NL) ;\r\n\r\nOUTPUT = '.OUT' '('$OUT1 ')' ;\r\n\r\nOUT1 = '*'     .OUT(.TB 'CI' .NL)   /\r\n       .STRING .OUT(.TB 'CL '* .NL) /\r\n       .NUMBER .OUT(.TB 'CC '* .NL) /\r\n       '#'     .OUT(.TB 'GN' .NL)   /\r\n       '.NL'   .OUT(.TB 'NL' .NL)   /\r\n       '.LB'   .OUT(.TB 'LB' .NL)   /\r\n       '.TB'   .OUT(.TB 'TB' .NL)   /\r\n       '.LM+'  .OUT(.TB 'LMI' .NL)  /\r\n       '.LM-'  .OUT(.TB 'LMD' .NL)  ;\r\n\r\nTX1 = TX2 $('/' .OUT(.TB 'BT T'# .NL) TX2) \r\n      .OUT(.LB 'T'# .NL) ;\r\n\r\nTX2 = TX3 .OUT(.TB 'BF T'# .NL)\r\n      $(TX3 .OUT(.TB 'RF' .NL) )\r\n      .OUT(.LB 'T'# .NL) ;\r\n\r\nTX3 = ( '.TOKEN'         .OUT(.TB 'TFT' .NL) /\r\n        '.DELTOK'        .OUT(.TB 'TFF' .NL) /\r\n        '$' .OUT(.LB 'T'# .NL) TX3 .OUT(.TB 'BT T'# .NL) ) \r\n                         .OUT(.TB 'SET' .NL)               /\r\n      '.ANYBUT(' CX1 ')' .OUT(.TB 'NOT' .NL .TB 'SCN' .NL) /\r\n      '.ANY(' CX1 ')'    .OUT(.TB 'SCN' .NL)               /\r\n      .ID                .OUT(.TB 'CLL ' * .NL)            /\r\n      '(' TX1 ')'                                          ;\r\n            \r\nCX1 = CX2 $('!' .OUT(.TB 'BT C'# .NL) CX2) .OUT(.LB 'C'# .NL) ;\r\nCX2 = CX3 (':' .OUT(.TB 'CGE ' * .NL) .OUT(.TB 'BF D'# .NL) \r\n               CX3\r\n               .OUT(.TB 'CLE ' * .NL) .OUT(.LB 'D' # .NL) /\r\n           .EMPTY .OUT(.TB 'CE ' * .NL)                   ) ;\r\nCX3 = .NUMBER ;\r\n\r\n.END\r\n"
    },
    {
        "filename": "i12jf__use_token_rules.txt",
        "contents": ".SYNTAX PROGRAM\r\n\r\nPROGRAM = '.SYNTAX' ID\r\n            .OUT(.LB '// '*' compiler' .NL)\r\n            .OUT('function compiler (input) {' .LM+ .NL)\r\n            .OUT('inbuf = input ;' .NL)\r\n            .OUT('inp = 0 ;' .NL)\r\n            .OUT('outbuf = \"\" ;' .NL)\r\n            .OUT('margin = 0 ;' .NL)\r\n            .OUT('gnlabel = 1 ;' .NL)\r\n            .OUT('runextTFF();' .NL)\r\n            .OUT('rule'*'() ;' .NL)\r\n            .OUT('return outbuf ;' .NL)\r\n            .OUT(.LM- '} ;' .NL .NL)\r\n          $ PR\r\n          '.TOKENS'\r\n          $ TR\r\n          '.END' ;\r\n\r\nPR = ID .OUT(.LB 'function rule'*' () {' .LM+ .NL)\r\n     .OUT('var rname = \"'*'\" ;' .NL)\r\n     .OUT('var rlabel = 0 ;' .NL)\r\n     '=' EX1 ';'\r\n     .OUT(.LM- '} ;' .NL .NL) ;\r\n\r\nTR = ID .OUT(.LB 'function rule'*' () {' .LM+ .NL)\r\n     .OUT('var rname = \"'*'\" ;' .NL)\r\n     .OUT('var rlabel = 0 ;' .NL)\r\n     ':' TX1 ';'\r\n     .OUT(.LM- '} ;' .NL .NL) ;\r\n\r\nEX1 = EX2 $('/' .OUT('if (!flag) {' .LM+ .NL) EX2 .OUT(.LM- '} ;' .NL) ) ;\r\n\r\nEX2 = (EX3 .OUT('if (flag) {' .LM+ .NL) / OUTPUT .OUT('if (true) {' .LM+ .NL) )\r\n      $(EX3 .OUT('if (!flag) runBEjsfn(rname);' .NL) / OUTPUT)\r\n      .OUT(.LM- '} ;' .NL) ;\r\n\r\nEX3 = ID        .OUT('rule'*'();' .NL)   /\r\n      STRING    .OUT('runTST(' 39 * 39 ');' .NL) /\r\n      '(' EX1 ')'                        /\r\n      '.EMPTY'  .OUT('runSET();' .NL)    /\r\n      '.LITCHR' .OUT('runextLCH();' .NL) /\r\n      '$' .OUT('runSET();' .NL)\r\n          .OUT('while (flag) {' .LM+ .NL)\r\n           EX3 \r\n          .OUT('};' .LM- .NL) \r\n          .OUT('runSET();' .NL) ;\r\n\r\nOUTPUT = '.OUT' '('$OUT1 ')' ;\r\n\r\nOUT1 = '*'    .OUT('runCI();' .NL)    /\r\n       STRING .OUT('runCL(' 39 * 39 ');' .NL) /\r\n       NUMBER .OUT('runextCC('*');' .NL) /\r\n       '#'    .OUT('if (rlabel == 0) { rlabel = gnlabel; gnlabel++ ; } ;' .NL)\r\n              .OUT('runCL(rlabel.toString());' .NL) /\r\n       '.NL'  .OUT('runextNL();' .NL)    /\r\n       '.LB'  .OUT('runLB();' .NL)       /\r\n       '.TB'  .OUT('runextTB();' .NL)    /\r\n       '.LM+' .OUT('runextLMI();' .NL)   /\r\n       '.LM-' .OUT('runextLMD();' .NL)   ;\r\n\r\nTX1 = TX2 $('/' .OUT('if (!flag) {' .LM+ .NL) TX2 .OUT(.LM- '} ;' .NL) ) ;\r\n\r\nTX2 = TX3 .OUT('if (flag) {' .LM+ .NL) \r\n      $(TX3 .OUT('if (!flag) return;' .NL) ) \r\n      .OUT(.LM- '} ;' .NL) ;\r\n\r\nTX3 = ( '.TOKEN'         .OUT('runextTFT();' .NL) /\r\n        '.DELTOK'        .OUT('runextTFF();' .NL) /\r\n        '$' .OUT('runSET();' .NL)\r\n            .OUT('while (flag) {' .LM+ .NL)\r\n             TX3 \r\n            .OUT('};' .LM- .NL)                   )\r\n        .OUT('runSET();' .NL)                       /\r\n      '.ANYBUT(' CX1 ')' .OUT('runextNOT();' .NL)\r\n                         .OUT('runextSCN();' .NL)   /\r\n      '.ANY(' CX1 ')'    .OUT('runextSCN();' .NL)   /\r\n      ID                 .OUT('rule'*'();' .NL)     /\r\n      '(' TX1 ')'                                   ;\r\n            \r\nCX1 = CX2 $('!' .OUT('if (!flag) {' .LM+ .NL) CX2 .OUT(.LM- '} ;' .NL) ) ;\r\nCX2 = CX3 (':' .OUT('runextCGE('*');' .NL) .OUT('if (flag) {' .LM+ .NL) \r\n               CX3\r\n               .OUT('runextCLE('*');' .NL) .OUT(.LM- '} ;' .NL) /\r\n           .EMPTY .OUT('runextCE('*');' .NL)                    ) ;\r\nCX3 = NUMBER ;\r\n\r\n.TOKENS\r\n\r\nPREFIX : $.ANY(32!9!13!10) ;\r\nID     : PREFIX .TOKEN ALPHA $(ALPHA/DIGIT) .DELTOK ;\r\nNUMBER : PREFIX .TOKEN DIGIT $DIGIT .DELTOK ;\r\nSTRING : PREFIX .ANY(39) .TOKEN $.ANYBUT(13!10!39) .DELTOK .ANY(39) ;\r\nALPHA  : .ANY(65:90!97:122) ;\r\nDIGIT  : .ANY(48:57) ;\r\n\r\n.END\r\n"
    },
    {
        "filename": "i12__use_token_rules.txt",
        "contents": ".SYNTAX PROGRAM\r\n\r\nPROGRAM = '.SYNTAX' ID .OUT(.LB .TB 'ADR ' * .NL)\r\n          $ PR  \r\n          '.TOKENS'\r\n          $ TR\r\n          '.END' .OUT(.TB 'END' .NL) ;\r\n\r\nPR = ID .OUT(.LB * .NL) '=' EX1 ';' .OUT(.TB 'R' .NL) ; \r\n\r\nTR = ID .OUT(.LB * .NL) ':' TX1 ';' .OUT(.TB 'R' .NL) ;\r\n\r\nEX1 = EX2 $('/' .OUT(.TB 'BT L'# .NL) EX2 )\r\n      .OUT(.LB 'L'# .NL) ;\r\n\r\nEX2 = (EX3 .OUT(.TB 'BF L'# .NL) / OUTPUT)\r\n      $(EX3 .OUT(.TB 'BE' .NL) / OUTPUT)\r\n      .OUT(.LB 'L'# .NL) ;\r\n\r\nEX3 = ID        .OUT(.TB 'CLL '* .NL)        /\r\n      STRING    .OUT(.TB 'TST ' 39 * 39 .NL) /\r\n      '(' EX1 ')'                            /\r\n      '.EMPTY'  .OUT(.TB 'SET' .NL)          /\r\n      '.LITCHR' .OUT(.TB 'LCH' .NL)          /\r\n      '$' .OUT(.LB 'L'# .NL) EX3 .OUT(.TB 'BT L'# .NL) .OUT(.TB 'SET' .NL) ;\r\n\r\nOUTPUT = '.OUT' '('$OUT1 ')' ;\r\n\r\nOUT1 = '*'     .OUT(.TB 'CI' .NL)          /\r\n       STRING  .OUT(.TB 'CL ' 39 * 39 .NL) /\r\n       NUMBER  .OUT(.TB 'CC '* .NL)        /\r\n       '#'     .OUT(.TB 'GN' .NL)          /\r\n       '.NL'   .OUT(.TB 'NL' .NL)          /\r\n       '.LB'   .OUT(.TB 'LB' .NL)          /\r\n       '.TB'   .OUT(.TB 'TB' .NL)          /\r\n       '.LM+'  .OUT(.TB 'LMI' .NL)         /\r\n       '.LM-'  .OUT(.TB 'LMD' .NL)         ;\r\n\r\nTX1 = TX2 $('/' .OUT(.TB 'BT T'# .NL) TX2) \r\n      .OUT(.LB 'T'# .NL) ;\r\n\r\nTX2 = TX3 .OUT(.TB 'BF T'# .NL)\r\n      $(TX3 .OUT(.TB 'RF' .NL) )\r\n      .OUT(.LB 'T'# .NL) ;\r\n\r\nTX3 = ( '.TOKEN'         .OUT(.TB 'TFT' .NL) /\r\n        '.DELTOK'        .OUT(.TB 'TFF' .NL) /\r\n        '$' .OUT(.LB 'T'# .NL) TX3 .OUT(.TB 'BT T'# .NL) ) \r\n                         .OUT(.TB 'SET' .NL)               /\r\n      '.ANYBUT(' CX1 ')' .OUT(.TB 'NOT' .NL .TB 'SCN' .NL) /\r\n      '.ANY(' CX1 ')'    .OUT(.TB 'SCN' .NL)               /\r\n      ID                 .OUT(.TB 'CLL ' * .NL)            /\r\n      '(' TX1 ')'                                          ;\r\n            \r\nCX1 = CX2 $('!' .OUT(.TB 'BT C'# .NL) CX2) .OUT(.LB 'C'# .NL) ;\r\nCX2 = CX3 (':' .OUT(.TB 'CGE ' * .NL) .OUT(.TB 'BF D'# .NL) \r\n               CX3\r\n               .OUT(.TB 'CLE ' * .NL) .OUT(.LB 'D' # .NL) /\r\n           .EMPTY .OUT(.TB 'CE ' * .NL)                   ) ;\r\nCX3 = NUMBER ;\r\n\r\n.TOKENS\r\n\r\nPREFIX : $.ANY(32!9!13!10) ;\r\nID     : PREFIX .TOKEN ALPHA $(ALPHA/DIGIT) .DELTOK ;\r\nNUMBER : PREFIX .TOKEN DIGIT $DIGIT .DELTOK ;\r\nSTRING : PREFIX .ANY(39) .TOKEN $.ANYBUT(13!10!39) .DELTOK .ANY(39) ;\r\nALPHA  : .ANY(65:90!97:122) ;\r\nDIGIT  : .ANY(48:57) ;\r\n\r\n.END\r\n"
    },
    {
        "filename": "i13jf__add_comments_and_litchr_to_i12jf.txt",
        "contents": ".SYNTAX PROGRAM\r\n\r\nPROGRAM = '.SYNTAX' ID\r\n            .OUT(.LB '// '*' compiler' .NL)\r\n            .OUT('function compiler (input) {' .LM+ .NL)\r\n            .OUT('inbuf = input ;' .NL)\r\n            .OUT('inp = 0 ;' .NL)\r\n            .OUT('outbuf = \"\" ;' .NL)\r\n            .OUT('margin = 0 ;' .NL)\r\n            .OUT('gnlabel = 1 ;' .NL)\r\n            .OUT('runextTFF();' .NL)\r\n            .OUT('rule'*'() ;' .NL)\r\n            .OUT('return outbuf ;' .NL)\r\n            .OUT(.LM- '} ;' .NL .NL)\r\n          $(PR / COMMENT)\r\n          '.TOKENS'\r\n          $(TR / COMMENT)\r\n          '.END' ;\r\n\r\nPR = ID .OUT(.LB 'function rule'*' () {' .LM+ .NL)\r\n     .OUT('var rname = \"'*'\" ;' .NL)\r\n     .OUT('var rlabel = 0 ;' .NL)\r\n     '=' EX1 ';'\r\n     .OUT(.LM- '} ;' .NL .NL) ;\r\n\r\nTR = ID .OUT(.LB 'function rule'*' () {' .LM+ .NL)\r\n     .OUT('var rname = \"'*'\" ;' .NL)\r\n     .OUT('var rlabel = 0 ;' .NL)\r\n     ':' TX1 ';'\r\n     .OUT(.LM- '} ;' .NL .NL) ;\r\n\r\nCOMMENT = '[' CMLINE ']' .OUT('//' * .NL) ;\r\n\r\nEX1 = EX2 $('/' .OUT('if (!flag) {' .LM+ .NL) EX2 .OUT(.LM- '} ;' .NL) ) ;\r\n\r\nEX2 = (EX3 .OUT('if (flag) {' .LM+ .NL) / OUTPUT .OUT('if (true) {' .LM+ .NL) )\r\n      $(EX3 .OUT('if (!flag) runBEjsfn(rname);' .NL) / OUTPUT)\r\n      .OUT(.LM- '} ;' .NL) ;\r\n\r\nEX3 = ID        .OUT('rule'*'();' .NL)   /\r\n      STRING    .OUT('runTST(' 39 * 39 ');' .NL) /\r\n      '(' EX1 ')'                        /\r\n      '.EMPTY'  .OUT('runSET();' .NL)    /\r\n      '.LITCHR' .OUT('runextLCH();' .NL) /\r\n      '$' .OUT('runSET();' .NL)\r\n          .OUT('while (flag) {' .LM+ .NL)\r\n           EX3 \r\n          .OUT('};' .LM- .NL) \r\n          .OUT('runSET();' .NL) ;\r\n\r\nOUTPUT = '.OUT' '('$OUT1 ')' ;\r\n\r\nOUT1 = '*'    .OUT('runCI();' .NL)    /\r\n       STRING .OUT('runCL(' 39 * 39 ');' .NL) /\r\n       NUMBER .OUT('runextCC('*');' .NL) /\r\n       '#'    .OUT('if (rlabel == 0) { rlabel = gnlabel; gnlabel++ ; } ;' .NL)\r\n              .OUT('runCL(rlabel.toString());' .NL) /\r\n       '.NL'  .OUT('runextNL();' .NL)    /\r\n       '.LB'  .OUT('runLB();' .NL)       /\r\n       '.TB'  .OUT('runextTB();' .NL)    /\r\n       '.LM+' .OUT('runextLMI();' .NL)   /\r\n       '.LM-' .OUT('runextLMD();' .NL)   ;\r\n\r\nTX1 = TX2 $('/' .OUT('if (!flag) {' .LM+ .NL) TX2 .OUT(.LM- '} ;' .NL) ) ;\r\n\r\nTX2 = TX3 .OUT('if (flag) {' .LM+ .NL) \r\n      $(TX3 .OUT('if (!flag) return;' .NL) ) \r\n      .OUT(.LM- '} ;' .NL) ;\r\n\r\nTX3 = ( '.TOKEN'         .OUT('runextTFT();' .NL) /\r\n        '.DELTOK'        .OUT('runextTFF();' .NL) /\r\n        '$' .OUT('runSET();' .NL)\r\n            .OUT('while (flag) {' .LM+ .NL)\r\n             TX3 \r\n            .OUT('};' .LM- .NL)                   )\r\n        .OUT('runSET();' .NL)                       /\r\n      '.ANYBUT(' CX1 ')' .OUT('runextNOT();' .NL)\r\n                         .OUT('runextSCN();' .NL)   /\r\n      '.ANY(' CX1 ')'    .OUT('runextSCN();' .NL)   /\r\n      ID                 .OUT('rule'*'();' .NL)     /\r\n      '(' TX1 ')'                                   ;\r\n            \r\nCX1 = CX2 $('!' .OUT('if (!flag) {' .LM+ .NL) CX2 .OUT(.LM- '} ;' .NL) ) ;\r\nCX2 = CX3 (':' .OUT('runextCGE('*');' .NL) .OUT('if (flag) {' .LM+ .NL) \r\n               CX3\r\n               .OUT('runextCLE('*');' .NL) .OUT(.LM- '} ;' .NL) /\r\n           .EMPTY .OUT('runextCE('*');' .NL)                    ) ;\r\nCX3 = NUMBER / SQUOTE .LITCHR ;\r\n\r\n.TOKENS\r\n\r\nPREFIX : $.ANY(32!9!13!10) ;\r\nID     : PREFIX .TOKEN ALPHA $(ALPHA/DIGIT) .DELTOK ;\r\nNUMBER : PREFIX .TOKEN DIGIT $DIGIT .DELTOK ;\r\nSTRING : PREFIX .ANY(39) .TOKEN $.ANYBUT(13!10!39) .DELTOK .ANY(39) ;\r\nALPHA  : .ANY(65:90!97:122) ;\r\nDIGIT  : .ANY(48:57) ;\r\nSQUOTE : PREFIX .ANY(39) ;\r\nCMLINE : .TOKEN $.ANYBUT(10!13!93) .DELTOK ;\r\n\r\n.END\r\n"
    },
    {
        "filename": "i13__add_comments_and_litchr_to_i12.txt",
        "contents": ".SYNTAX PROGRAM\r\n\r\nPROGRAM = '.SYNTAX' ID .OUT(.LB .TB 'ADR ' * .NL)\r\n          $(PR / COMMENT)  \r\n          '.TOKENS'\r\n          $(TR / COMMENT)\r\n          '.END' .OUT(.TB 'END' .NL) ;\r\n\r\nPR = ID .OUT(.LB * .NL) '=' EX1 ';' .OUT(.TB 'R' .NL) ; \r\n\r\nTR = ID .OUT(.LB * .NL) ':' TX1 ';' .OUT(.TB 'R' .NL) ;\r\n\r\nCOMMENT = '[' CMLINE ']' .OUT(.LB ';' * .NL) ;\r\n\r\nEX1 = EX2 $('/' .OUT(.TB 'BT L'# .NL) EX2 )\r\n      .OUT(.LB 'L'# .NL) ;\r\n\r\nEX2 = (EX3 .OUT(.TB 'BF L'# .NL) / OUTPUT)\r\n      $(EX3 .OUT(.TB 'BE' .NL) / OUTPUT)\r\n      .OUT(.LB 'L'# .NL) ;\r\n\r\nEX3 = ID        .OUT(.TB 'CLL '* .NL)        /\r\n      STRING    .OUT(.TB 'TST ' 39 * 39 .NL) /\r\n      '(' EX1 ')'                            /\r\n      '.EMPTY'  .OUT(.TB 'SET' .NL)          /\r\n      '.LITCHR' .OUT(.TB 'LCH' .NL)          /\r\n      '$' .OUT(.LB 'L'# .NL) EX3 .OUT(.TB 'BT L'# .NL) .OUT(.TB 'SET' .NL) ;\r\n\r\nOUTPUT = '.OUT' '('$OUT1 ')' ;\r\n\r\nOUT1 = '*'     .OUT(.TB 'CI' .NL)          /\r\n       STRING  .OUT(.TB 'CL ' 39 * 39 .NL) /\r\n       NUMBER  .OUT(.TB 'CC '* .NL)        /\r\n       '#'     .OUT(.TB 'GN' .NL)          /\r\n       '.NL'   .OUT(.TB 'NL' .NL)          /\r\n       '.LB'   .OUT(.TB 'LB' .NL)          /\r\n       '.TB'   .OUT(.TB 'TB' .NL)          /\r\n       '.LM+'  .OUT(.TB 'LMI' .NL)         /\r\n       '.LM-'  .OUT(.TB 'LMD' .NL)         ;\r\n\r\nTX1 = TX2 $('/' .OUT(.TB 'BT T'# .NL) TX2) \r\n      .OUT(.LB 'T'# .NL) ;\r\n\r\nTX2 = TX3 .OUT(.TB 'BF T'# .NL)\r\n      $(TX3 .OUT(.TB 'RF' .NL) )\r\n      .OUT(.LB 'T'# .NL) ;\r\n\r\nTX3 = ( '.TOKEN'         .OUT(.TB 'TFT' .NL) /\r\n        '.DELTOK'        .OUT(.TB 'TFF' .NL) /\r\n        '$' .OUT(.LB 'T'# .NL) TX3 .OUT(.TB 'BT T'# .NL) ) \r\n                         .OUT(.TB 'SET' .NL)               /\r\n      '.ANYBUT(' CX1 ')' .OUT(.TB 'NOT' .NL .TB 'SCN' .NL) /\r\n      '.ANY(' CX1 ')'    .OUT(.TB 'SCN' .NL)               /\r\n      ID                 .OUT(.TB 'CLL ' * .NL)            /\r\n      '(' TX1 ')'                                          ;\r\n            \r\nCX1 = CX2 $('!' .OUT(.TB 'BT C'# .NL) CX2) .OUT(.LB 'C'# .NL) ;\r\nCX2 = CX3 (':' .OUT(.TB 'CGE ' * .NL) .OUT(.TB 'BF D'# .NL) \r\n               CX3\r\n               .OUT(.TB 'CLE ' * .NL) .OUT(.LB 'D' # .NL) /\r\n           .EMPTY .OUT(.TB 'CE ' * .NL)                   ) ;\r\nCX3 = NUMBER / SQUOTE .LITCHR ;\r\n\r\n.TOKENS\r\n\r\nPREFIX : $.ANY(32!9!13!10) ;\r\nID     : PREFIX .TOKEN ALPHA $(ALPHA/DIGIT) .DELTOK ;\r\nNUMBER : PREFIX .TOKEN DIGIT $DIGIT .DELTOK ;\r\nSTRING : PREFIX .ANY(39) .TOKEN $.ANYBUT(13!10!39) .DELTOK .ANY(39) ;\r\nALPHA  : .ANY(65:90!97:122) ;\r\nDIGIT  : .ANY(48:57) ;\r\nSQUOTE : PREFIX .ANY(39) ;\r\nCMLINE : .TOKEN $.ANYBUT(10!13!93) .DELTOK ;\r\n\r\n.END\r\n"
    },
    {
        "filename": "i14jf__use_comments_and_litchr.txt",
        "contents": ".SYNTAX PROGRAM\r\n[ Example Metacompiler Definition ]\r\n[ javascript function version ]\r\n[ James M. Neighbors ]\r\n\r\n[ body of compiler definition ]\r\nPROGRAM = '.SYNTAX' ID\r\n            .OUT(.LB '// '*' compiler' .NL)\r\n            .OUT('function compiler (input) {' .LM+ .NL)\r\n            .OUT('inbuf = input ;' .NL)\r\n            .OUT('inp = 0 ;' .NL)\r\n            .OUT('outbuf = \"\" ;' .NL)\r\n            .OUT('margin = 0 ;' .NL)\r\n            .OUT('gnlabel = 1 ;' .NL)\r\n            .OUT('runextTFF();' .NL)\r\n            .OUT('rule'*'() ;' .NL)\r\n            .OUT('return outbuf ;' .NL)\r\n            .OUT(.LM- '} ;' .NL .NL)\r\n          $(PR / COMMENT)\r\n          '.TOKENS'\r\n          $(TR / COMMENT)\r\n          '.END' ;\r\n\r\n[ parsing rule definition ]\r\nPR = ID .OUT(.LB 'function rule'*' () {' .LM+ .NL)\r\n     .OUT('var rname = \"'*'\" ;' .NL)\r\n     .OUT('var rlabel = 0 ;' .NL)\r\n     '=' EX1 ';'\r\n     .OUT(.LM- '} ;' .NL .NL) ;\r\n\r\n[ token rule definition ]\r\nTR = ID .OUT(.LB 'function rule'*' () {' .LM+ .NL)\r\n     .OUT('var rname = \"'*'\" ;' .NL)\r\n     .OUT('var rlabel = 0 ;' .NL)\r\n     ':' TX1 ';'\r\n     .OUT(.LM- '} ;' .NL .NL) ;\r\n\r\n[ comment definition ]\r\nCOMMENT = '[' CMLINE ']' .OUT('//' * .NL) ;\r\n\r\n[ parsing expressions ]\r\nEX1 = EX2 $('/' .OUT('if (!flag) {' .LM+ .NL) EX2 .OUT(.LM- '} ;' .NL) ) ;\r\n\r\nEX2 = (EX3 .OUT('if (flag) {' .LM+ .NL) / OUTPUT .OUT('if (true) {' .LM+ .NL) )\r\n      $(EX3 .OUT('if (!flag) runBEjsfn(rname);' .NL) / OUTPUT)\r\n      .OUT(.LM- '} ;' .NL) ;\r\n\r\nEX3 = ID        .OUT('rule'*'();' .NL)   /\r\n      STRING    .OUT('runTST(' 39 * 39 ');' .NL) /\r\n      '(' EX1 ')'                        /\r\n      '.EMPTY'  .OUT('runSET();' .NL)    /\r\n      '.LITCHR' .OUT('runextLCH();' .NL) /\r\n      '$' .OUT('runSET();' .NL)\r\n          .OUT('while (flag) {' .LM+ .NL)\r\n           EX3 \r\n          .OUT('};' .LM- .NL) \r\n          .OUT('runSET();' .NL) ;\r\n\r\n[ output expressions ]\r\nOUTPUT = '.OUT' '('$OUT1 ')' ;\r\n\r\nOUT1 = '*'    .OUT('runCI();' .NL)    /\r\n       STRING .OUT('runCL(' 39 * 39 ');' .NL) /\r\n       NUMBER .OUT('runextCC('*');' .NL) /\r\n       '#'    .OUT('if (rlabel == 0) { rlabel = gnlabel; gnlabel++ ; } ;' .NL)\r\n              .OUT('runCL(rlabel.toString());' .NL) /\r\n       '.NL'  .OUT('runextNL();' .NL)    /\r\n       '.LB'  .OUT('runLB();' .NL)       /\r\n       '.TB'  .OUT('runextTB();' .NL)    /\r\n       '.LM+' .OUT('runextLMI();' .NL)   /\r\n       '.LM-' .OUT('runextLMD();' .NL)   ;\r\n\r\n[ token expressions ]\r\nTX1 = TX2 $('/' .OUT('if (!flag) {' .LM+ .NL) TX2 .OUT(.LM- '} ;' .NL) ) ;\r\n\r\nTX2 = TX3 .OUT('if (flag) {' .LM+ .NL) \r\n      $(TX3 .OUT('if (!flag) return;' .NL) ) \r\n      .OUT(.LM- '} ;' .NL) ;\r\n\r\nTX3 = ( '.TOKEN'         .OUT('runextTFT();' .NL) /\r\n        '.DELTOK'        .OUT('runextTFF();' .NL) /\r\n        '$' .OUT('runSET();' .NL)\r\n            .OUT('while (flag) {' .LM+ .NL)\r\n             TX3 \r\n            .OUT('};' .LM- .NL)                   )\r\n        .OUT('runSET();' .NL)                       /\r\n      '.ANYBUT(' CX1 ')' .OUT('runextNOT();' .NL)\r\n                         .OUT('runextSCN();' .NL)   /\r\n      '.ANY(' CX1 ')'    .OUT('runextSCN();' .NL)   /\r\n      ID                 .OUT('rule'*'();' .NL)     /\r\n      '(' TX1 ')'                                   ;\r\n            \r\n[ character expressions ]            \r\nCX1 = CX2 $('!' .OUT('if (!flag) {' .LM+ .NL) CX2 .OUT(.LM- '} ;' .NL) ) ;\r\nCX2 = CX3 (':' .OUT('runextCGE('*');' .NL) .OUT('if (flag) {' .LM+ .NL) \r\n               CX3\r\n               .OUT('runextCLE('*');' .NL) .OUT(.LM- '} ;' .NL) /\r\n           .EMPTY .OUT('runextCE('*');' .NL)                    ) ;\r\nCX3 = NUMBER / SQUOTE .LITCHR ;\r\n\r\n[ token definitions ]\r\n.TOKENS\r\n\r\nPREFIX : $.ANY(32!9!13!10) ;\r\nID     : PREFIX .TOKEN ALPHA $(ALPHA/DIGIT) .DELTOK ;\r\nNUMBER : PREFIX .TOKEN DIGIT $DIGIT .DELTOK ;\r\nSTRING : PREFIX .ANY(39) .TOKEN $.ANYBUT(13!10!39) .DELTOK .ANY(39) ;\r\nALPHA  : .ANY('A:'Z!'a:'z) ;\r\nDIGIT  : .ANY('0:'9) ;\r\nSQUOTE : PREFIX .ANY('') ;\r\nCMLINE : .TOKEN $.ANYBUT(10!13!']) .DELTOK ;\r\n\r\n.END\r\n"
    },
    {
        "filename": "i14js__convert_i14jf_to_js_object.txt",
        "contents": ".SYNTAX PROGRAM\r\n[ Example Metacompiler Definition ]\r\n[ fully contained javascript object version ]\r\n[ James M. Neighbors ]\r\n\r\n[ body of compiler definition ]\r\nPROGRAM = '.SYNTAX' ID \r\n          .OUT(.LB '// ' * ' compiler' .NL)\r\n          .OUT('compiler = {' .LM+ .NL .NL)\r\n          PREAMBLE\r\n          $(PR / COMMENT)  \r\n          '.TOKENS'\r\n          $(TR / COMMENT)\r\n          '.END' \r\n          POSTAMBLE \r\n          .OUT(.LM- '}' .NL) ;     \r\n                                            \r\n[ object definition preamble ]\r\nPREAMBLE = .OUT('compile: function (input) {' .LM+ .NL)\r\n           .OUT('// initialize compiler variables' .NL)\r\n           .OUT('this.inbuf = input ;' .NL)\r\n           .OUT('this.initialize() ;' .NL)\r\n           .OUT('// call the first rule' .NL)\r\n           .OUT('this.ctxpush(' 39 * 39 ') ;' .NL)\r\n           .OUT('this.rule' * '() ;' .NL)\r\n           .OUT('this.ctxpop() ;' .NL)\r\n           .OUT('// special case handling of first rule failure' .NL)\r\n           .OUT('if ((!this.eflag) && (!this.pflag)) {' .LM+ .NL)\r\n           .OUT('this.eflag = true ;' .NL)\r\n           .OUT('this.erule = ' 39 * 39 ' ;' .NL)\r\n           .OUT('this.einput = this.inp ; } ;' .LM- .NL)\r\n           .OUT('return this.eflag ;' .NL)\r\n           .OUT(.LM- '},' .NL .NL) ;\r\n\r\n\r\n[ runtime and object definition postamble ] \r\nPOSTAMBLE = \r\n           .OUT('// runtime variables' .NL)\r\n           .OUT('pflag: false ,' .NL)\r\n           .OUT('tflag: false ,' .NL)\r\n           .OUT('eflag: false ,' .NL)\r\n           .OUT('inp: 0 ,' .NL)\r\n           .OUT('inbuf:  ' 39 39 ' ,' .NL)\r\n           .OUT('outbuf:  ' 39 39 ' ,' .NL)\r\n           .OUT('erule:  ' 39 39 ' ,' .NL)\r\n           .OUT('einput: 0 ,' .NL)\r\n           .OUT('token: ' 39 39 ' ,' .NL)\r\n           .OUT('labelcount: 0 ,' .NL)\r\n           .OUT('stackframesize: 3 ,' .NL)\r\n           .OUT('stackframe: 0 ,' .NL)\r\n           .OUT('stos: -1 ,' .NL)\r\n           .OUT('stack: [] ,' .NL .NL)\r\n\r\n           .OUT('initialize: function () {'.LM+ .NL)\r\n           .OUT('// initialize for another compile' .NL)\r\n           .OUT('this.pflag = false ;' .NL)\r\n           .OUT('this.tflag = false ;' .NL)\r\n           .OUT('this.eflag = false ;' .NL)\r\n           .OUT('this.inp = 0 ;' .NL)\r\n           .OUT('this.outbuf = ' 39 39 ' ;' .NL)\r\n           .OUT('this.erule = ' 39 39 ' ;' .NL)\r\n           .OUT('this.einput = 0 ;' .NL)\r\n           .OUT('this.token = ' 39 39 ' ;' .NL)\r\n           .OUT('this.labelcount = 1 ;' .NL)\r\n           .OUT('this.stackframe = -1 ;' .NL)\r\n           .OUT('this.stos = -1 ;' .NL)\r\n           .OUT('this.stack = [] ;' .NL)\r\n           .OUT(.LM- '},' .NL .NL)\r\n\r\n           .OUT('ctxpush: function (rulename){' .LM+ .NL)\r\n           .OUT('// push and initialize a new stackframe' .NL)\r\n           .OUT('var LM ;' .NL)  \r\n           .OUT('// new context inherits current context left margin' .NL)\r\n           .OUT('LM = 0; if (this.stackframe >= 0) LM = this.stack[this.stackframe + 2] ;' .NL)\r\n           .OUT('this.stos++ ;' .NL)\r\n           .OUT('this.stackframe = this.stos * this.stackframesize ;' .NL)\r\n           .OUT('// stackframe definition' .NL)\r\n           .OUT('this.stack[this.stackframe + 0] = 0 ;        // generated label' .NL)\r\n           .OUT('this.stack[this.stackframe + 1] = rulename ; // called rule name' .NL)\r\n           .OUT('this.stack[this.stackframe + 2] = LM ;       // left margin' .NL)\r\n           .OUT(.LM- '},' .NL .NL) \r\n\r\n           .OUT('ctxpop: function (){' .LM+ .NL)\r\n           .OUT('// pop and possibly deallocate old stackframe' .NL)\r\n           .OUT('this.stos-- ; // pop stackframe' .NL)\r\n           .OUT('this.stackframe = this.stos * this.stackframesize ;' .NL)\r\n           .OUT(.LM- '},' .NL .NL)          \r\n\r\n           .OUT('out: function (s){' .LM+ .NL)\r\n           .OUT('// output string' .NL)\r\n           .OUT('var i ;' .NL)\r\n           .OUT('// if newline last output, add left margin before string' .NL)\r\n           .OUT('if (this.outbuf.charAt(this.outbuf.length - 1) == ' 39 92 'n' 39 ') {' .NL)\r\n           .OUT('  i = this.stack[this.stackframe + 2] ;' .NL)\r\n           .OUT('  while (i>0) { this.outbuf += ' 39 ' ' 39 ' ; i-- } ; } ;' .NL)\r\n           .OUT('this.outbuf += s ;' .NL)\r\n           .OUT(.LM- '},' .NL .NL)\r\n\r\n           .OUT('eol: function (){' .LM+ .NL)\r\n           .OUT('// output end of line' .NL)\r\n           .OUT('this.outbuf += ' 39 92 'n' 39 ' ;' .NL)\r\n           .OUT(.LM- '},' .NL .NL)\r\n\r\n           .OUT('test: function (s) {' .LM+ .NL)\r\n           .OUT('// test for a string in the input' .NL)\r\n           .OUT('var i ;' .NL)\r\n           .OUT('// delete whitespace' .NL) \r\n           .OUT('while ((this.inbuf.charAt(this.inp) == ' 39 ' ' 39 ')  ||' .NL)\r\n           .OUT('       (this.inbuf.charAt(this.inp) == ' 39 92 'n' 39 ') ||' .NL) \r\n           .OUT('       (this.inbuf.charAt(this.inp) == ' 39 92 'r' 39 ') ||' .NL)\r\n           .OUT('       (this.inbuf.charAt(this.inp) == ' 39 92 't' 39 ') ) this.inp++ ;' .NL)\r\n           .OUT('// test string case insensitive' .NL) \r\n           .OUT('this.pflag = true ; i = 0 ;' .NL)\r\n           .OUT('while (this.pflag && (i < s.length) && ((this.inp+i) < this.inbuf.length) )' .NL)\r\n           .OUT('{ this.pflag = (s.charAt(i).toUpperCase() ==' .NL)\r\n           .OUT('                this.inbuf.charAt(this.inp+i).toUpperCase()) ;' .NL)\r\n           .OUT('  i++ ; } ;' .NL)\r\n           .OUT('this.pflag = this.pflag && (i == s.length) ;' .NL)\r\n           .OUT('// advance input if found' .NL) \r\n           .OUT('if (this.pflag) this.inp = this.inp + s.length ;' .NL)\r\n           .OUT(.LM- '},' .NL .NL)\r\n\r\n           .OUT('err: function () {' .LM+ .NL)\r\n           .OUT('// compilation error, provide error indication and context' .NL)\r\n           .OUT('this.eflag = true ;' .NL)\r\n           .OUT('this.erule = this.stack[this.stackframe + 1] ;' .NL)\r\n           .OUT('this.einput = this.inp ;' .NL)\r\n           .OUT(.LM- '}' .NL .NL) ;\r\n\r\n[ parsing rule definition ]\r\nPR = ID .OUT('rule'* ': function () {' .LM+ .NL)\r\n     '=' EX1 ';'\r\n     .OUT(.LM- '} ,' .NL .NL) ;\r\n\r\n[ token rule definition ]\r\nTR = ID .OUT('rule'* ': function () {' .LM+ .NL)\r\n     ':' TX1 ';'\r\n     .OUT(.LM- '} ,' .NL .NL) ;\r\n\r\n[ comment definition ]\r\nCOMMENT = '[' CMLINE ']' .OUT('//' * .NL) ;\r\n\r\n[ parsing expressions ]\r\nEX1 = EX2 $('/' .OUT('if (!this.pflag) {' .LM+ .NL) EX2 .OUT(.LM- '} ;' .NL) ) ;\r\n\r\nEX2 = (EX3 .OUT('if (this.pflag) {' .LM+ .NL) / OUTPUT .OUT('if (true) {' .LM+ .NL) )\r\n      $(EX3 .OUT('if (!this.pflag) this.err();' .NL) / OUTPUT)\r\n      .OUT(.LM- '} ;' .NL) ;\r\n\r\n\r\nEX3 = ID        .OUT('this.ctxpush(' 39 * 39 ') ;' .NL)\r\n                .OUT('this.rule' * '() ;' .NL)\r\n                .OUT('this.ctxpop() ;' .NL)\r\n                .OUT('if (this.eflag) return ;' .NL)  /\r\n      STRING    .OUT('this.test(' 39 * 39 ');' .NL) /\r\n      '(' EX1 ')'                            /\r\n      '.EMPTY'  .OUT('this.pflag = true ;' .NL)    /\r\n      '.LITCHR' .OUT('this.token = this.inbuf.charCodeAt(this.inp) ;' .NL)\r\n                .OUT('this.inp++ ;' .NL)  /\r\n      '$' .OUT('this.pflag = true ;' .NL)\r\n          .OUT('while (this.pflag) {' .LM+ .NL)\r\n           EX3 \r\n          .OUT(.LM- '} ;' .NL)\r\n          .OUT('this.pflag = true ;' .NL) ;\r\n\r\n[ output expressions ]\r\nOUTPUT = '.OUT' '('$OUT1 ')' ;\r\n\r\nOUT1 = '*'     .OUT('this.out(this.token) ;' .NL)          /\r\n       STRING  .OUT('this.out(' 39 * 39 ') ;' .NL) /\r\n       NUMBER  .OUT('this.out(String.fromCharCode(' * ')) ;' .NL)        /\r\n       '#'     .OUT('if (this.stack[this.stackframe + 0] == 0) {' .LM+ .NL) \r\n               .OUT('this.stack[this.stackframe + 0] = this.labelcount ;' .NL)\r\n               .OUT('this.labelcount++ ; } ;' .LM- .NL) \r\n               .OUT('this.out(this.stack[this.stackframe + 0]) ;' .NL) /\r\n       '.NL'   .OUT('this.eol() ;' .NL)          /\r\n       '.LB'             /\r\n       '.TB'   .OUT('this.out(' 39 92 't' 39 ') ;' .NL)          /\r\n       '.LM+'  .OUT('this.stack[this.stackframe + 2] += 2 ;' .NL) /\r\n       '.LM-'  .OUT('this.stack[this.stackframe + 2] -= 2 ;' .NL) ;\r\n\r\n[ token expressions ]\r\nTX1 = TX2 $('/' .OUT('if (!this.pflag) {' .LM+ .NL) TX2 .OUT(.LM- '} ;' .NL) ) ;\r\n\r\nTX2 = TX3 .OUT('if (this.pflag) {' .LM+ .NL) \r\n      $(TX3 .OUT('if (!this.pflag) return;' .NL) ) \r\n      .OUT(.LM- '} ;' .NL) ;\r\n\r\nTX3 = ( '.TOKEN'  .OUT('this.tflag = true ; ' .NL)\r\n                  .OUT('this.token = ' 39 39 ' ;' .NL) /\r\n        '.DELTOK' .OUT('this.tflag = false ;' .NL) /\r\n        '$' .OUT('this.pflag = true ;' .NL)\r\n            .OUT('while (this.pflag) {' .LM+ .NL)\r\n             TX3 \r\n            .OUT(.LM- '};' .NL) )\r\n        .OUT('this.pflag = true ;' .NL) /\r\n      '.ANYBUT(' CX1 ')' .OUT('this.pflag = !this.pflag ;' .NL) \r\n        .OUT('if (this.pflag) {' .LM+ .NL)\r\n        .OUT('if (this.tflag) this.token += this.inbuf.charAt(this.inp) ;' .NL)\r\n        .OUT('this.inp++ } ;' .LM- .NL) /\r\n      '.ANY(' CX1 ')' \r\n        .OUT('if (this.pflag) {' .LM+ .NL)\r\n        .OUT('if (this.tflag) this.token += this.inbuf.charAt(this.inp) ;' .NL)\r\n        .OUT('this.inp++ } ;' .LM- .NL) /\r\n      ID                 \r\n        .OUT('this.ctxpush(' 39 * 39 ') ;' .NL)\r\n        .OUT('this.rule' * '() ;' .NL)\r\n        .OUT('this.ctxpop() ;' .NL)\r\n        .OUT('if (this.eflag) return ;' .NL)  /\r\n      '(' TX1 ')'  ;\r\n\r\n[ character expressions ]            \r\nCX1 = .OUT('this.pflag = ' .LM+ .NL)\r\n      CX2 $('!' .OUT(' ||' .NL) CX2)\r\n      .OUT(.LM- ' ;' .NL) ;\r\nCX2 = CX3 (':' .OUT('((this.inbuf.charCodeAt(this.inp) >= ' * ') &&' .NL)\r\n               CX3\r\n               .OUT(' (this.inbuf.charCodeAt(this.inp) <= ' * ')  )' ) /\r\n           .EMPTY .OUT('(this.inbuf.charCodeAt(this.inp) == ' * ') ' )  ) ;\r\nCX3 = NUMBER / SQUOTE .LITCHR ;\r\n\r\n[ token definitions ]\r\n.TOKENS\r\n\r\nPREFIX : $.ANY(32!9!13!10) ;\r\nID     : PREFIX .TOKEN ALPHA $(ALPHA/DIGIT) .DELTOK ;\r\nNUMBER : PREFIX .TOKEN DIGIT $DIGIT .DELTOK ;\r\nSTRING : PREFIX .ANY(39) .TOKEN $.ANYBUT(13!10!39) .DELTOK .ANY(39) ;\r\nALPHA  : .ANY('A:'Z!'a:'z) ;\r\nDIGIT  : .ANY('0:'9) ;\r\nSQUOTE : PREFIX .ANY('') ;\r\nCMLINE : .TOKEN $.ANYBUT(10!13!']) .DELTOK ;\r\n\r\n.END\r\n"
    },
    {
        "filename": "i14__use_comments_and_litchr.txt",
        "contents": ".SYNTAX PROGRAM\r\n[ Example Metacompiler Definition ]\r\n[ interpreter code version ]\r\n[ James M. Neighbors ]\r\n\r\n[ body of compiler definition ]\r\nPROGRAM = '.SYNTAX' ID .OUT(.LB .TB 'ADR ' * .NL)\r\n          $(PR / COMMENT)  \r\n          '.TOKENS'\r\n          $(TR / COMMENT)\r\n          '.END' .OUT(.TB 'END' .NL) ;\r\n\r\n[ parsing rule definition ]\r\nPR = ID .OUT(.LB * .NL) '=' EX1 ';' .OUT(.TB 'R' .NL) ; \r\n\r\n[ token rule definition ]\r\nTR = ID .OUT(.LB * .NL) ':' TX1 ';' .OUT(.TB 'R' .NL) ;\r\n\r\n[ comment definition ]\r\nCOMMENT = '[' CMLINE ']' .OUT(.LB ';' * .NL) ;\r\n\r\n[ parsing expressions ]\r\nEX1 = EX2 $('/' .OUT(.TB 'BT L'# .NL) EX2 )\r\n      .OUT(.LB 'L'# .NL) ;\r\n\r\nEX2 = (EX3 .OUT(.TB 'BF L'# .NL) / OUTPUT)\r\n      $(EX3 .OUT(.TB 'BE' .NL) / OUTPUT)\r\n      .OUT(.LB 'L'# .NL) ;\r\n\r\nEX3 = ID        .OUT(.TB 'CLL '* .NL)        /\r\n      STRING    .OUT(.TB 'TST ' 39 * 39 .NL) /\r\n      '(' EX1 ')'                            /\r\n      '.EMPTY'  .OUT(.TB 'SET' .NL)          /\r\n      '.LITCHR' .OUT(.TB 'LCH' .NL)          /\r\n      '$' .OUT(.LB 'L'# .NL) EX3 .OUT(.TB 'BT L'# .NL) .OUT(.TB 'SET' .NL) ;\r\n\r\n[ output expressions ]\r\nOUTPUT = '.OUT' '('$OUT1 ')' ;\r\n\r\nOUT1 = '*'     .OUT(.TB 'CI' .NL)          /\r\n       STRING  .OUT(.TB 'CL ' 39 * 39 .NL) /\r\n       NUMBER  .OUT(.TB 'CC '* .NL)        /\r\n       '#'     .OUT(.TB 'GN' .NL)          /\r\n       '.NL'   .OUT(.TB 'NL' .NL)          /\r\n       '.LB'   .OUT(.TB 'LB' .NL)          /\r\n       '.TB'   .OUT(.TB 'TB' .NL)          /\r\n       '.LM+'  .OUT(.TB 'LMI' .NL)         /\r\n       '.LM-'  .OUT(.TB 'LMD' .NL)         ;\r\n\r\n[ token expressions ]\r\nTX1 = TX2 $('/' .OUT(.TB 'BT T'# .NL) TX2) \r\n      .OUT(.LB 'T'# .NL) ;\r\n\r\nTX2 = TX3 .OUT(.TB 'BF T'# .NL)\r\n      $(TX3 .OUT(.TB 'RF' .NL) )\r\n      .OUT(.LB 'T'# .NL) ;\r\n\r\nTX3 = ( '.TOKEN'         .OUT(.TB 'TFT' .NL) /\r\n        '.DELTOK'        .OUT(.TB 'TFF' .NL) /\r\n        '$' .OUT(.LB 'T'# .NL) TX3 .OUT(.TB 'BT T'# .NL) ) \r\n                         .OUT(.TB 'SET' .NL)               /\r\n      '.ANYBUT(' CX1 ')' .OUT(.TB 'NOT' .NL .TB 'SCN' .NL) /\r\n      '.ANY(' CX1 ')'    .OUT(.TB 'SCN' .NL)               /\r\n      ID                 .OUT(.TB 'CLL ' * .NL)            /\r\n      '(' TX1 ')'                                          ;\r\n\r\n[ character expressions ]            \r\nCX1 = CX2 $('!' .OUT(.TB 'BT C'# .NL) CX2) .OUT(.LB 'C'# .NL) ;\r\nCX2 = CX3 (':' .OUT(.TB 'CGE ' * .NL) .OUT(.TB 'BF D'# .NL) \r\n               CX3\r\n               .OUT(.TB 'CLE ' * .NL) .OUT(.LB 'D' # .NL) /\r\n           .EMPTY .OUT(.TB 'CE ' * .NL)                   ) ;\r\nCX3 = NUMBER / SQUOTE .LITCHR ;\r\n\r\n[ token definitions ]\r\n.TOKENS\r\n\r\nPREFIX : $.ANY(32!9!13!10) ;\r\nID     : PREFIX .TOKEN ALPHA $(ALPHA/DIGIT) .DELTOK ;\r\nNUMBER : PREFIX .TOKEN DIGIT $DIGIT .DELTOK ;\r\nSTRING : PREFIX .ANY(39) .TOKEN $.ANYBUT(13!10!39) .DELTOK .ANY(39) ;\r\nALPHA  : .ANY('A:'Z!'a:'z) ;\r\nDIGIT  : .ANY('0:'9) ;\r\nSQUOTE : PREFIX .ANY('') ;\r\nCMLINE : .TOKEN $.ANYBUT(10!13!']) .DELTOK ;\r\n\r\n.END\r\n"
    },
    {
        "filename": "i15js__js_metacompiler_with_backup.txt",
        "contents": ".SYNTAX PROGRAM\r\n[ Example Metacompiler Definition ]\r\n[ fully contained javascript object version with backup ]\r\n[ James M. Neighbors ]\r\n\r\n[ body of compiler definition ]\r\nPROGRAM = '.SYNTAX' ID \r\n          .OUT(.LB '// ' * ' compiler' .NL)\r\n          .OUT('compiler = {' .LM+ .NL .NL)\r\n          PREAMBLE\r\n          $(PR / COMMENT)  \r\n          '.TOKENS'\r\n          $(TR / COMMENT)\r\n          '.END' \r\n          POSTAMBLE \r\n          .OUT(.LM- '}' .NL) ;     \r\n                                            \r\n[ object definition preamble ]\r\nPREAMBLE = .OUT('compile: function (input) {' .LM+ .NL)\r\n           .OUT('// initialize compiler variables' .NL)\r\n           .OUT('this.inbuf = input ;' .NL)\r\n           .OUT('this.initialize() ;' .NL)\r\n           .OUT('// call the first rule' .NL)\r\n           .OUT('this.ctxpush(' 39 * 39 ') ;' .NL)\r\n           .OUT('this.rule' * '() ;' .NL)\r\n           .OUT('this.ctxpop() ;' .NL)\r\n           .OUT('// special case handling of first rule failure' .NL)\r\n           .OUT('if ((!this.eflag) && (!this.pflag)) {' .LM+ .NL)\r\n           .OUT('this.eflag = true ;' .NL)\r\n           .OUT('this.erule = ' 39 * 39 ' ;' .NL)\r\n           .OUT('this.einput = this.inp ; } ;' .LM- .NL)\r\n           .OUT('return this.eflag ;' .NL)\r\n           .OUT(.LM- '},' .NL .NL) ;\r\n\r\n\r\n[ runtime and object definition postamble ] \r\nPOSTAMBLE = \r\n           .OUT('// runtime variables' .NL)\r\n           .OUT('pflag: false ,' .NL)\r\n           .OUT('tflag: false ,' .NL)\r\n           .OUT('eflag: false ,' .NL)\r\n           .OUT('inp: 0 ,' .NL)\r\n           .OUT('inbuf:  ' 39 39 ' ,' .NL)\r\n           .OUT('outbuf:  ' 39 39 ' ,' .NL)\r\n           .OUT('erule:  ' 39 39 ' ,' .NL)\r\n           .OUT('einput: 0 ,' .NL)\r\n           .OUT('token: ' 39 39 ' ,' .NL)\r\n           .OUT('labelcount: 0 ,' .NL)\r\n           .OUT('stackframesize: 6 ,' .NL)\r\n           .OUT('stackframe: 0 ,' .NL)\r\n           .OUT('stos: -1 ,' .NL)\r\n           .OUT('stack: [] ,' .NL .NL)\r\n\r\n           .OUT('initialize: function () {'.LM+ .NL)\r\n           .OUT('// initialize for another compile' .NL)\r\n           .OUT('this.pflag = false ;' .NL)\r\n           .OUT('this.tflag = false ;' .NL)\r\n           .OUT('this.eflag = false ;' .NL)\r\n           .OUT('this.inp = 0 ;' .NL)\r\n           .OUT('this.outbuf = ' 39 39 ' ;' .NL)\r\n           .OUT('this.erule = ' 39 39 ' ;' .NL)\r\n           .OUT('this.einput = 0 ;' .NL)\r\n           .OUT('this.token = ' 39 39 ' ;' .NL)\r\n           .OUT('this.labelcount = 1 ;' .NL)\r\n           .OUT('this.stackframe = -1 ;' .NL)\r\n           .OUT('this.stos = -1 ;' .NL)\r\n           .OUT('this.stack = [] ;' .NL)\r\n           .OUT(.LM- '},' .NL .NL)\r\n\r\n           .OUT('ctxpush: function (rulename){' .LM+ .NL)\r\n           .OUT('// push and initialize a new stackframe' .NL)\r\n           .OUT('var LM ;' .NL)  \r\n           .OUT('// new context inherits current context left margin' .NL)\r\n           .OUT('LM = 0; if (this.stackframe >= 0) LM = this.stack[this.stackframe + 2] ;' .NL)\r\n           .OUT('this.stos++ ;' .NL)\r\n           .OUT('this.stackframe = this.stos * this.stackframesize ;' .NL)\r\n           .OUT('// stackframe definition' .NL)\r\n           .OUT('this.stack[this.stackframe + 0] = 0 ;        // generated label' .NL)\r\n           .OUT('this.stack[this.stackframe + 1] = rulename ; // called rule name' .NL)\r\n           .OUT('this.stack[this.stackframe + 2] = LM ;       // left margin' .NL)\r\n           .OUT('// clear additional stackframe backtracking entries' .NL)\r\n           .OUT('this.bkclear() ;' .NL)\r\n           .OUT(.LM- '},' .NL .NL)\r\n\r\n           .OUT('ctxpop: function (){' .LM+ .NL)\r\n           .OUT('// pop and possibly deallocate old stackframe' .NL)\r\n           .OUT('this.stos-- ; // pop stackframe' .NL)\r\n           .OUT('this.stackframe = this.stos * this.stackframesize ;' .NL)\r\n           .OUT(.LM- '},' .NL .NL)          \r\n\r\n           .OUT('out: function (s){' .LM+ .NL)\r\n           .OUT('// output string' .NL)\r\n           .OUT('var i ;' .NL)\r\n           .OUT('// if newline last output, add left margin before string' .NL)\r\n           .OUT('if (this.outbuf.charAt(this.outbuf.length - 1) == ' 39 92 'n' 39 ') {' .NL)\r\n           .OUT('  i = this.stack[this.stackframe + 2] ;' .NL)\r\n           .OUT('  while (i>0) { this.outbuf += ' 39 ' ' 39 ' ; i-- } ; } ;' .NL)\r\n           .OUT('this.outbuf += s ;' .NL)\r\n           .OUT(.LM- '},' .NL .NL)\r\n\r\n           .OUT('eol: function (){' .LM+ .NL)\r\n           .OUT('// output end of line' .NL)\r\n           .OUT('this.outbuf += ' 39 92 'n' 39 ' ;' .NL)\r\n           .OUT(.LM- '},' .NL .NL)\r\n\r\n           .OUT('test: function (s) {' .LM+ .NL)\r\n           .OUT('// test for a string in the input' .NL)\r\n           .OUT('var i ;' .NL)\r\n           .OUT('// delete whitespace' .NL) \r\n           .OUT('while ((this.inbuf.charAt(this.inp) == ' 39 ' ' 39 ')  ||' .NL)\r\n           .OUT('       (this.inbuf.charAt(this.inp) == ' 39 92 'n' 39 ') ||' .NL) \r\n           .OUT('       (this.inbuf.charAt(this.inp) == ' 39 92 'r' 39 ') ||' .NL)\r\n           .OUT('       (this.inbuf.charAt(this.inp) == ' 39 92 't' 39 ') ) this.inp++ ;' .NL)\r\n           .OUT('// test string case insensitive' .NL) \r\n           .OUT('this.pflag = true ; i = 0 ;' .NL)\r\n           .OUT('while (this.pflag && (i < s.length) && ((this.inp+i) < this.inbuf.length) )' .NL)\r\n           .OUT('{ this.pflag = (s.charAt(i).toUpperCase() ==' .NL)\r\n           .OUT('                this.inbuf.charAt(this.inp+i).toUpperCase()) ;' .NL)\r\n           .OUT('  i++ ; } ;' .NL)\r\n           .OUT('this.pflag = this.pflag && (i == s.length) ;' .NL)\r\n           .OUT('// advance input if found' .NL) \r\n           .OUT('if (this.pflag) this.inp = this.inp + s.length ;' .NL)\r\n           .OUT(.LM- '},' .NL .NL)\r\n\r\n           .OUT('bkerr: function () {' .LM+ .NL)\r\n           .OUT('// compilation error, provide error indication and context' .NL)\r\n           .OUT('this.eflag = true ;' .NL)\r\n           .OUT('this.erule = this.stack[this.stackframe + 1] ;' .NL)\r\n           .OUT('this.einput = this.inp ;' .NL)\r\n           .OUT(.LM- '},' .NL .NL)\r\n\r\n           .OUT('bkset: function () {' .LM+ .NL)\r\n           .OUT('// set backtrack context on stack' .NL)\r\n           .OUT('this.stack[this.stackframe + 3] = this.inp ;           // input position' .NL)\r\n           .OUT('this.stack[this.stackframe + 4] = this.outbuf.length ; // output position' .NL)\r\n           .OUT('this.stack[this.stackframe + 5] = this.token ;         // current token' .NL)\r\n           .OUT(.LM- '},' .NL .NL)\r\n\r\n           .OUT('bkclear: function () {' .LM+ .NL)\r\n           .OUT('// clear backtrack context on stack' .NL)\r\n           .OUT('this.stack[this.stackframe + 3] = -1 ; // input position' .NL)\r\n           .OUT('this.stack[this.stackframe + 4] = -1 ; // output position' .NL)\r\n           .OUT('this.stack[this.stackframe + 5] = ' 39 39 ' ; // current token' .NL)\r\n           .OUT(.LM- '},' .NL .NL)\r\n\r\n           .OUT('bkrestore: function () {' .LM+ .NL)\r\n           .OUT('// restore context for backtracking' .NL)\r\n           .OUT('this.eflag = false ;' .NL)\r\n           .OUT('this.inp = this.stack[this.stackframe + 3] ;           // input position' .NL)\r\n           .OUT('this.outbuf = this.outbuf.substring(0,this.stack[this.stackframe + 4]) ; // output position' .NL)\r\n           .OUT('this.token = this.stack[this.stackframe + 5] ;         // current token' .NL)\r\n           .OUT(.LM- '}' .NL .NL) ;\r\n\r\n[ parsing rule definition ]\r\nPR = ID .OUT('rule'* ': function () {' .LM+ .NL)\r\n     '=' EX1 ';'\r\n     .OUT(.LM- '} ,' .NL .NL) ;\r\n\r\n[ token rule definition ]\r\nTR = ID .OUT('rule'* ': function () {' .LM+ .NL)\r\n     ':' TX1 ';'\r\n     .OUT(.LM- '} ,' .NL .NL) ;\r\n\r\n[ comment definition ]\r\nCOMMENT = '[' CMLINE ']' .OUT('//' * .NL) ;\r\n\r\n[ parsing expressions ]\r\nEX1 = EX2 $('/' .OUT('if ((!this.pflag) && (!this.eflag)) {' .LM+ .NL)\r\n                EX2\r\n                .OUT(.LM- '} ;' .NL) ) ;\r\n\r\nEX2 = (EX3 .OUT('if (this.pflag) {' .LM+ .NL) /\r\n       OUTPUT .OUT('if (true) {' .LM+ .NL) )\r\n      .OUT('while (!this.eflag) {' .LM+ .NL)\r\n      $(EX3 .OUT('if (!this.pflag) this.bkerr();' .NL)\r\n            .OUT('if (this.eflag) break ;' .NL) /\r\n        OUTPUT)\r\n      .OUT('break }' .LM- .NL)\r\n      .OUT(.LM- '} ;' .NL) ;\r\n\r\nEX3 = ID        .OUT('this.ctxpush(' 39 * 39 ') ;' .NL)\r\n                .OUT('this.rule' * '() ;' .NL)\r\n                .OUT('this.ctxpop() ;' .NL) /\r\n      STRING    .OUT('this.test(' 39 * 39 ');' .NL) /\r\n      '(' EX1 ')'                            /\r\n      '.EMPTY'  .OUT('this.pflag = true ;' .NL)    /\r\n      '.LITCHR' .OUT('this.token = this.inbuf.charCodeAt(this.inp) ;' .NL)\r\n                .OUT('this.inp++ ;' .NL)  /\r\n      '.PASS'   .OUT('this.inp = 0 ;' .NL)  /\r\n      '$' .OUT('this.pflag = true ;' .NL)\r\n          .OUT('while (this.pflag & !this.eflag) {' .LM+ .NL)\r\n           EX3 \r\n          .OUT(.LM- '} ;' .NL)\r\n          .OUT('this.pflag = !this.eflag ;' .NL) /\r\n      '[' .OUT('this.bkset() ;' .NL)\r\n          EX1\r\n          $('|' .OUT('if (!this.pflag) {' .LM+ .NL)\r\n                .OUT('if (this.eflag) this.bkrestore() ;' .NL)\r\n                EX1\r\n                .OUT(.LM- '} ;' .NL) )\r\n      ']' .OUT('if (this.eflag) this.bkrestore() ;' .NL)\r\n          .OUT('this.bkclear() ;' .NL) ;\r\n\r\n[ output expressions ]\r\nOUTPUT = '.OUT' '('$OUT1 ')' ;\r\n\r\nOUT1 = '*'     .OUT('this.out(this.token) ;' .NL)          /\r\n       STRING  .OUT('this.out(' 39 * 39 ') ;' .NL) /\r\n       NUMBER  .OUT('this.out(String.fromCharCode(' * ')) ;' .NL)        /\r\n       '#'     .OUT('if (this.stack[this.stackframe + 0] == 0) {' .LM+ .NL) \r\n               .OUT('this.stack[this.stackframe + 0] = this.labelcount ;' .NL)\r\n               .OUT('this.labelcount++ ; } ;' .LM- .NL) \r\n               .OUT('this.out(this.stack[this.stackframe + 0]) ;' .NL) /\r\n       '.NL'   .OUT('this.eol() ;' .NL)          /\r\n       '.LB'             /\r\n       '.TB'   .OUT('this.out(' 39 92 't' 39 ') ;' .NL)          /\r\n       '.LM+'  .OUT('this.stack[this.stackframe + 2] += 2 ;' .NL) /\r\n       '.LM-'  .OUT('this.stack[this.stackframe + 2] -= 2 ;' .NL) ;\r\n\r\n[ token expressions ]\r\nTX1 = TX2 $('/' .OUT('if (!this.pflag) {' .LM+ .NL) TX2 .OUT(.LM- '} ;' .NL) ) ;\r\n\r\nTX2 = TX3 .OUT('if (this.pflag) {' .LM+ .NL) \r\n      $(TX3 .OUT('if (!this.pflag) return;' .NL) ) \r\n      .OUT(.LM- '} ;' .NL) ;\r\n\r\nTX3 = ( '.TOKEN'  .OUT('this.tflag = true ; ' .NL)\r\n                  .OUT('this.token = ' 39 39 ' ;' .NL) /\r\n        '.DELTOK' .OUT('this.tflag = false ;' .NL) /\r\n        '$' .OUT('this.pflag = true ;' .NL)\r\n            .OUT('while (this.pflag) {' .LM+ .NL)\r\n             TX3 \r\n            .OUT(.LM- '};' .NL) )\r\n        .OUT('this.pflag = true ;' .NL) /\r\n      '.ANYBUT(' CX1 ')' .OUT('this.pflag = !this.pflag ;' .NL) \r\n        .OUT('if (this.pflag) {' .LM+ .NL)\r\n        .OUT('if (this.tflag) this.token += this.inbuf.charAt(this.inp) ;' .NL)\r\n        .OUT('this.inp++ } ;' .LM- .NL) /\r\n      '.ANY(' CX1 ')' \r\n        .OUT('if (this.pflag) {' .LM+ .NL)\r\n        .OUT('if (this.tflag) this.token += this.inbuf.charAt(this.inp) ;' .NL)\r\n        .OUT('this.inp++ } ;' .LM- .NL) /\r\n      ID                 \r\n        .OUT('this.ctxpush(' 39 * 39 ') ;' .NL)\r\n        .OUT('this.rule' * '() ;' .NL)\r\n        .OUT('this.ctxpop() ;' .NL)\r\n        .OUT('if (this.eflag) return ;' .NL)  /\r\n      '(' TX1 ')'  ;\r\n\r\n[ character expressions ]            \r\nCX1 = .OUT('this.pflag = ' .LM+ .NL)\r\n      CX2 $('!' .OUT(' ||' .NL) CX2)\r\n      .OUT(.LM- ' ;' .NL) ;\r\nCX2 = CX3 (':' .OUT('((this.inbuf.charCodeAt(this.inp) >= ' * ') &&' .NL)\r\n               CX3\r\n               .OUT(' (this.inbuf.charCodeAt(this.inp) <= ' * ')  )' ) /\r\n           .EMPTY .OUT('(this.inbuf.charCodeAt(this.inp) == ' * ') ' )  ) ;\r\nCX3 = NUMBER / SQUOTE .LITCHR ;\r\n\r\n[ token definitions ]\r\n.TOKENS\r\n\r\nPREFIX : $.ANY(32!9!13!10) ;\r\nID     : PREFIX .TOKEN ALPHA $(ALPHA/DIGIT) .DELTOK ;\r\nNUMBER : PREFIX .TOKEN DIGIT $DIGIT .DELTOK ;\r\nSTRING : PREFIX .ANY(39) .TOKEN $.ANYBUT(13!10!39) .DELTOK .ANY(39) ;\r\nALPHA  : .ANY('A:'Z!'a:'z) ;\r\nDIGIT  : .ANY('0:'9) ;\r\nSQUOTE : PREFIX .ANY('') ;\r\nCMLINE : .TOKEN $.ANYBUT(10!13!']) .DELTOK ;\r\n\r\n.END\r\n"
    },
    {
        "filename": "i16__extract_syntax_to_output.txt",
        "contents": ".SYNTAX SYNTAX\r\n[ strip compiler definition to syntax equations in standard form ]\r\n[ accepts Meta II and modified syntax ]\r\n[ James M. Neighbors ]\r\n\r\n[ body of compiler definition ]\r\nSYNTAX = '.SYNTAX' ID .OUT(.LB '.SYNTAX ' * .NL .NL)\r\n         $(PR / COMMENT)  \r\n         ( '.TOKENS' .OUT(.LB '.TOKENS' .NL .NL)\r\n                     $(TR / COMMENT) \r\n                     .OUT(.NL) /\r\n           .EMPTY )\r\n         '.END' .OUT(.LB '.END' .NL) ;\r\n\r\n[ parsing rule definition ]\r\nPR = ID '=' .OUT(.LB * ' = ' .LM+ ) \r\n     EX1 \r\n     (';' / '.,') \r\n     .OUT(.LM- ';' .NL .NL); \r\n\r\n[ token rule definition ]\r\nTR = ID ':' .OUT(.LB * ' : ' .LM+ ) TX1 ';' .OUT(.LM- ';' .NL ) ; \r\n\r\n[ comment definition ]\r\nCOMMENT = '[' CMLINE ']' ;\r\n\r\n[ parsing expressions ]\r\nEX1 = EX2 $('/' .OUT('/ ') EX2 ) ;\r\n\r\nEX2 = (EX3 .OUT(' ') / OUTPUT) $(EX3 .OUT(' ') / OUTPUT) ;\r\n\r\nEX3 = ID        .OUT(*)         /\r\n      STRING    .OUT(39 * 39)   /\r\n      '(' .OUT(.LM+ '( ') \r\n          EX1 \r\n      ')' .OUT(.LM- ')')        /\r\n      '.EMPTY'  .OUT('.EMPTY')  /\r\n      '.LITCHR' .OUT('.LITCHR') /\r\n      '$' .OUT('$') EX3         /\r\n      '.ID'     .OUT('.ID')     /\r\n      '.NUMBER' .OUT('.NUMBER') /\r\n      '.STRING' .OUT('.STRING') /\r\n      '[' .OUT('[ ')\r\n          EX1 $('|' .OUT('| ') EX1)\r\n      ']' .OUT(']') ;\r\n\r\n[ output expressions ]\r\nOUTPUT = '.OUT' '('$OUT1 ')' / '.LABEL' OUT1 ;\r\n\r\nOUT1 = '*1'    /\r\n       '*2'    /\r\n       '*'     /\r\n       STRING  /\r\n       NUMBER  /\r\n       '#'     /\r\n       '.NL'   /\r\n       '.LB'   /\r\n       '.TB'   /\r\n       '.LM+'  /\r\n       '.LM-'  ;\r\n\r\n[ token expressions ]\r\nTX1 = TX2 $('/' .OUT('/ ') TX2) ; \r\n\r\nTX2 = TX3 .OUT(' ') $(TX3 .OUT(' ')) ;\r\n\r\nTX3 = '.TOKEN'         .OUT('.TOKEN') /\r\n      '.DELTOK'        .OUT('.DELTOK') /\r\n      '$' .OUT('$') TX3  /\r\n      '.ANYBUT(' .OUT('.ANYBUT(')\r\n          CX1 \r\n          ')' .OUT(')')     /\r\n      '.ANY(' .OUT('.ANY(')\r\n          CX1 \r\n          ')' .OUT(')')     /\r\n      ID      .OUT(*)       /\r\n      '(' .OUT('(') \r\n          TX1 \r\n      ')' .OUT(')')         ;\r\n\r\n[ character expressions ]            \r\nCX1 = CX2 $('!' .OUT('!') CX2) ;\r\nCX2 = CX3 (':' .OUT(':') CX3 /\r\n           .EMPTY            ) ;\r\nCX3 = NUMBER .OUT(*) / SQUOTE .LITCHR .OUT(*) ;\r\n\r\n[ token definitions ]\r\n.TOKENS\r\n\r\nPREFIX : $.ANY(32!9!13!10) ;\r\nID     : PREFIX .TOKEN ALPHA $(ALPHA/DIGIT) .DELTOK ;\r\nNUMBER : PREFIX .TOKEN DIGIT $DIGIT .DELTOK ;\r\nSTRING : PREFIX .ANY(39) .TOKEN $.ANYBUT(13!10!39) .DELTOK .ANY(39) ;\r\nALPHA  : .ANY('A:'Z!'a:'z) ;\r\nDIGIT  : .ANY('0:'9) ;\r\nSQUOTE : PREFIX .ANY('') ;\r\nCMLINE : .TOKEN $.ANYBUT(10!13!']) .DELTOK ;\r\n\r\n.END\r\n"
    },
];
